<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/infinity-solid.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/infinity-solid.svg">
  <link rel="mask-icon" href="/images/infinity-solid.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="">


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"falt"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="XBD">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="XBD">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Baoduo Xu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>XBD</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XBD</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Everything will end up being TRIVIAL.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        
      
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/29/seminar/july2023/exact-algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/29/seminar/july2023/exact-algorithms/" class="post-title-link" itemprop="url">精确算法：动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-29 20:44:09" itemprop="dateCreated datePublished" datetime="2023-07-29T20:44:09+08:00">2023-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-10 23:21:37" itemprop="dateModified" datetime="2023-08-10T23:21:37+08:00">2023-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/29/seminar/july2023/exact-algorithms/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/29/seminar/july2023/exact-algorithms/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>默认连通图.</p>
<h1 id="最大独立集">最大独立集</h1>
<p>独立集一些简单的结论:</p>
<ul>
<li>若 <span class="math inline">\(v\in I\)</span>, 则 <span
class="math inline">\(N(v)\cap I=\emptyset\)</span>.</li>
<li>若 <span class="math inline">\(I\)</span> 是 MIS, 则对于 <span
class="math inline">\(v\not\in I\)</span>, <span
class="math inline">\(N(v)\)</span> 中至少有一个点在 <span
class="math inline">\(I\)</span> 中即 <span
class="math inline">\(|N(v)\cap I|\ge 1\)</span>, 如若不然, <span
class="math inline">\(I\cup\{v\}\)</span> 可称为新的独立集.</li>
<li>对于每一个 <span class="math inline">\(v\in V\)</span> 和MIS <span
class="math inline">\(I\)</span>, 存在一个 <span
class="math inline">\(y\in N[v]\)</span> 使得 <span
class="math inline">\(y\in I\)</span> 但 <span
class="math inline">\(N(y)\cap I=\emptyset\)</span>.</li>
</ul>
<blockquote>
<p>第三条怎么和第一条重复了?</p>
</blockquote>
<p>下面是递推关系式: <span class="math display">\[
\alpha(G)=
\begin{cases}
0,&amp; V=\emptyset\\
\displaystyle 1+\max_{y\in N[v],v=\arg\min_{u\in V(G)}\deg
(u)}\alpha(G\backslash\ N[y]),&amp;\text{otherwise}
\end{cases}
\]</span> 复杂度为 <span class="math inline">\(O^*(s^{n/s}),s=\min_{v\in
V}\deg(v)+1\)</span>, <span class="math inline">\(s=3\)</span> 时为<span
class="math inline">\(O^*(3^{n/3})\)</span> 是最大值. 这个复杂度分析并不
trivial, 先贴在下面:</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/20230730170842.png" /></p>
<h1 id="染色">染色</h1>
<p>染色问题的暴力复杂度为 <span
class="math inline">\(O(n^n)\)</span>.</p>
<p>由于染色问题要求相邻两点颜色不同, 可以考虑借助独立集的性质,
在给定的图上加上一些互不相邻的点后色数恰好加一(或者说染色后每一种颜色的顶点集合都是一个独立集),
对于 <span class="math inline">\(X\subset V\)</span>, 记 <span
class="math inline">\(f(X)=\chi(G[X])\)</span>, <span
class="math inline">\(G[X]\)</span> 的最大独立集集合为 <span
class="math inline">\(\mathcal{I}_X\)</span>, 那么就有下面的递推 <span
class="math display">\[
f(X)
=
\begin{cases}
0,&amp;X=\emptyset\\
\displaystyle 1+\min_{I\in \mathcal{I}_X} f(X\backslash
I),&amp;\text{otherwise}.
\end{cases}
\]</span> 可以断言 <span
class="math inline">\(\chi(G)=f(V)\)</span>.</p>
<p>这个 DP 算法的复杂度为 <span
class="math inline">\(O^*((1+\sqrt[3]{3})^n)\)</span>,
证明需要用到上面最大独立集的 branching 算法的时间复杂度.</p>
<p>先把证明贴到下面:</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/1690711871888.png" /></p>
<h1 id="最小支配集">最小支配集</h1>
<p>首先叙述最小支配集问题与集合覆盖问题 <span
class="math inline">\((\cal U,S)\)</span> 的关系: 令 <span
class="math inline">\(\mathcal{U}=V, \mathcal{S}=\{N[v]:v\in V
\}\)</span>, 可以将求解最小支配集的问题转化为集合覆盖问题. 称 <span
class="math inline">\(u\)</span> 被 <span
class="math inline">\(v\)</span> 支配当且仅当 <span
class="math inline">\(u\in N(v)\)</span>, 那么 <span
class="math inline">\(N[v]\)</span> 是所有被 <span
class="math inline">\(v\)</span> 支配的点的集合, 因此对于 <span
class="math inline">\(D\subset V\)</span>, <span
class="math inline">\(D\)</span> 是最小支配集当且仅当 <span
class="math inline">\(\{N[v]:v\in D\}\)</span> 能够覆盖 <span
class="math inline">\(\{N[v]:v\in V\}\)</span>.</p>
<p>对于一般的图 <span class="math inline">\(G\)</span> 而言,
存在一个求解其最小支配集的动态规划算法, 时间复杂度为 <span
class="math inline">\(O(n^{O(1)}2^{n-|I|})\)</span>, 其中 <span
class="math inline">\(I\)</span> 为最大独立集, 特别地, 对于二分图而言
<span class="math inline">\(|I|=n/2\)</span>, 时间复杂度为 <span
class="math inline">\(O^*(2^{n/2})\)</span>. 下面叙述这个算法.</p>
<p>设 <span class="math inline">\(J=V\backslash I\)</span>, 首先 <span
class="math inline">\(J\)</span> 一定是支配集, 考虑反证法, 假设存在
<span class="math inline">\(v\in I\)</span> 且 <span
class="math inline">\(v\)</span> 没有被 <span
class="math inline">\(J\)</span> 支配, 那么 <span
class="math inline">\(v\)</span> 不与 <span
class="math inline">\(J\)</span> 中的点相邻, 而 <span
class="math inline">\(v\)</span> 又不与 <span
class="math inline">\(I\)</span> 中的相邻, 那么 <span
class="math inline">\(v\)</span> 就是一个孤立的点,
而我们只考虑连通图.</p>
<p>考虑枚举 <span class="math inline">\(V\)</span> 的子集 <span
class="math inline">\(D\)</span> 在 <span
class="math inline">\(J\)</span> 上的投影来寻找最小支配集, 令 <span
class="math inline">\(J_D=J\cap D\)</span>, 逐步向 <span
class="math inline">\(J_D\)</span> 中添加 <span
class="math inline">\(I\)</span> 中的顶点, 可以得到支配集. ?</p>
<p>对于每个 <span class="math inline">\(J_D\subset J\)</span>, 令 <span
class="math inline">\(|D|=\min\{|D&#39;|:D&#39;\text{ is a dominating
set}\land J\cap D&#39;=J_D\}\)</span>, 那么就有<span
class="math inline">\(\gamma(G)=\min_{J_D\subset J}|D|\)</span>.</p>
<p>令 <span class="math inline">\(I_D=I\backslash N(J_D)\)</span>,
表示最大独立集 <span class="math inline">\(I\)</span> 中没有被 <span
class="math inline">\(J_D\)</span> 支配的部分, 再令 <span
class="math inline">\(J_X=J\backslash(N(J_D)\cup N(I_D))\)</span> 表示
<span class="math inline">\(J\)</span> 中没有被 <span
class="math inline">\(J_D\cup I_D\)</span> 支配的部分, 那么通过置 <span
class="math inline">\(\mathcal{U}=J_X,\mathcal{S}=\{N[v]:v\in
I\backslash I_D \}\)</span>,
便可将原问题转化成一个新的规模稍小一些的集合覆盖问题,
这个集合覆盖问题可以在 <span
class="math inline">\(O(n^{O(1)}2^{|J_X|})\)</span> 内解决,
那么总的时间复杂度为 <span
class="math inline">\(O(3^{n-|I|})\)</span>.</p>
<blockquote>
<p>看不懂. 先放弃了. 以后有时间再看吧. /kk</p>
</blockquote>
<p>剩下是设计一个新的动态规划算法将时间复杂度从 <span
class="math inline">\(O^*(3^{n-|I|})\)</span> 降到 <span
class="math inline">\(O^*(2^{n-|I|})\)</span> 的过程.</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308031143234.png" /></p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/27/math/graph/graph-problems/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/27/math/graph/graph-problems/" class="post-title-link" itemprop="url">典型图论问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-27 17:53:44" itemprop="dateCreated datePublished" datetime="2023-07-27T17:53:44+08:00">2023-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-30 16:28:18" itemprop="dateModified" datetime="2023-07-30T16:28:18+08:00">2023-07-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/27/math/graph/graph-problems/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/27/math/graph/graph-problems/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>对典型的图论问题的描述做一下汇总,
仅仅介绍问题的基本描述和问题之间的联系, 下面所有问题都是在图 <span
class="math inline">\(G=(V,E)\)</span> 的基础上描述的, 默认为无向图.</p>
<p>1: <strong>匹配</strong>. 图 <span class="math inline">\(G\)</span>
的一个匹配 <span class="math inline">\(M\)</span> 是 <span
class="math inline">\(E\)</span> 的子集, 满足 <span
class="math inline">\(M\)</span> 中的任意两条边都没有公共的顶点.
<strong>最大匹配问题</strong>要求找到满足最大的满足条件的 <span
class="math inline">\(M\)</span>.</p>
<p>2: <strong>覆盖</strong>. 图 <span class="math inline">\(G\)</span>
的一个覆盖 <span class="math inline">\(R\)</span> 是顶点 <span
class="math inline">\(V\)</span> 的子集, 满足 <span
class="math inline">\(E\)</span> 中的任意一条边中的某个端点在 <span
class="math inline">\(R\)</span> 中.
最小覆盖问题要求找到最小的满足条件的 <span
class="math inline">\(R\)</span>.</p>
<p>3: <strong>集合覆盖(Set Cover)</strong>. 对于给定的集合 <span
class="math inline">\(U\)</span> 和集合<span
class="math inline">\(\mathcal{S}\subset \mathcal{P}(U)\)</span>, 若
<span class="math inline">\(\mathcal{S}&#39;\subset \mathcal{S}\)</span>
满足 <span class="math inline">\(\bigcup_{S\subset
\mathcal{S}&#39;}S=U\)</span>, 则称 <span
class="math inline">\(\mathcal{S}&#39;\)</span> 覆盖集合 <span
class="math inline">\(U\)</span>.
最小集合覆盖(MSC)问题要求找到最小的满足条件的 <span
class="math inline">\(\mathcal{S}&#39;\)</span>.</p>
<p>4: <strong>独立集(Independent Set)</strong>. 图 <span
class="math inline">\(G\)</span> 的独立集 <span
class="math inline">\(I\)</span> 是顶点集 <span
class="math inline">\(V\)</span> 的子集, 满足 <span
class="math inline">\(I\)</span> 中的任意一对顶点都不相邻.
最大独立集(MIS)问题要求找到最大的满足条件的 <span
class="math inline">\(I\)</span>, 同时将最大的 <span
class="math inline">\(|I|\)</span> 记作图 <span
class="math inline">\(G\)</span> 的独立数 <span
class="math inline">\(\alpha(G)\)</span>.</p>
<p>5: <strong>支配集(Dominant Set)</strong>. 图 <span
class="math inline">\(G\)</span> 的支配集 <span
class="math inline">\(D\)</span> 是顶点集 <span
class="math inline">\(V\)</span> 的子集, 满足 <span
class="math inline">\(V\)</span> 可以被划分为 <span
class="math inline">\(D\)</span> 和 <span
class="math inline">\(N(D)=\bigcup_{v\in D}N(v)\)</span>.
最小支配集(MDS)问题要求找到最小的满足条件的 <span
class="math inline">\(D\)</span>, 同时将最小的 <span
class="math inline">\(|D|\)</span> 记作图 <span
class="math inline">\(G\)</span> 的支配数 <span
class="math inline">\(\gamma(G)\)</span>.</p>
<p>6: <strong>染色(Graph Coloring)</strong>. 无向图 <span
class="math inline">\(G\)</span> 的 <span
class="math inline">\(k\)</span>-coloring <span
class="math inline">\(c:V\to [k]\)</span> 满足 <span
class="math inline">\(\forall\{u,v\}\in E,c(u)\ne c(v)\)</span>, 即使用
<span class="math inline">\(k\)</span> 种颜色给图 <span
class="math inline">\(G\)</span> 的每个顶点都分配一种颜色,
使得相邻顶点的颜色都不相同. 最小的能给 <span
class="math inline">\(G\)</span> 进行上述染色过程的 <span
class="math inline">\(k\)</span> 称为图 <span
class="math inline">\(G\)</span> 的色数, 记作 <span
class="math inline">\(\chi(G)\)</span>, <span
class="math inline">\(c:V\to [\chi(G)]\)</span> 称为最优染色(optimal
coloring). 染色问题要求找到图 <span class="math inline">\(G\)</span>
的色数 <span class="math inline">\(\chi(G)\)</span> 或者更进一步地,
最优的染色方案 <span class="math inline">\(c\)</span>.</p>
<p>7: 最优树(最短路, 最小生成树, Steiner Tree)</p>
<p>8: 网络流(最大流, 最小费用流, 最小割)</p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/essay/essay/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/essay/essay/" class="post-title-link" itemprop="url">一些做题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-25 20:18:59" itemprop="dateCreated datePublished" datetime="2023-07-25T20:18:59+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-16 23:39:57" itemprop="dateModified" datetime="2023-08-16T23:39:57+08:00">2023-08-16</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/25/essay/essay/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/25/essay/essay/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<h1 id="p2949">P2949</h1>
<p>优先队列<code>priority_queue</code>默认大根堆, 如果要实现小根堆:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;q;</span><br></pre></td></tr></table></figure></p>
<p>优先队列的元素为 <code>pair&lt;int,int&gt;</code> 时,
入队的排序依据为第一个元素.</p>
<p>结构体入队时, 通过重载实现比较方式:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_foo</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &gt; (_foo x,_foo y)&#123; <span class="comment">// 一般不重载 &lt;</span></span><br><span class="line">        <span class="keyword">return</span> x.b &lt; y.b; <span class="comment">// 符号相同为大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;foo;</span><br><span class="line">priority_queue&lt;foo&gt;q; <span class="comment">// 小根堆</span></span><br></pre></td></tr></table></figure>
<h1 id="loj10001">LOJ10001</h1>
<p>https://loj.ac/p/10001</p>
<p>暴力可过, 先假设每个点都种即 <code>ans=n</code>,
然后从头到尾扫描一遍, 如果不种不违反约束条件(不会导致某个区间的树不够)就
<code>ans--</code>, <span class="math inline">\(O(nh)\)</span>.</p>
<p>更快的方法是差分约束, 考虑前缀和, 约束条件可以转化为 <span
class="math inline">\(S_{e_j}-S_{b_j -1}\ge t_j\)</span> 的形式.
(没学过, 有时间再学)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://loj.ac/p/10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5e3</span>,maxn2=<span class="number">3e4</span>;</span><br><span class="line"><span class="type">int</span> sug[maxn+<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> num[maxn+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,h,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">        cin&gt;&gt;sug[i][<span class="number">0</span>]&gt;&gt;sug[i][<span class="number">1</span>]&gt;&gt;sug[i][<span class="number">2</span>];</span><br><span class="line">        num[i]=sug[i][<span class="number">1</span>]-sug[i][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=sug[i][<span class="number">0</span>]&amp;&amp;k&lt;=sug[i][<span class="number">1</span>]&amp;&amp;num[i]==sug[i][<span class="number">2</span>])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            ans--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=sug[i][<span class="number">0</span>]&amp;&amp;k&lt;=sug[i][<span class="number">1</span>])&#123;</span><br><span class="line">                    num[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="loj10002">LOJ10002</h1>
<p>首先考虑每个圆能够覆盖的区间,
用勾股定理将问题转化为从若干区间中选择最少的能覆盖给定区间的区间.
接着按照右端点排序, 从左到右进行覆盖, 记录当前能覆盖到的区间的右端点
<code>crt</code>, 在剩下的区间中选择左端点小于 <code>crt</code>
的且右端点最大的区间即可, 当不存在这样的区间或者最大的区间右端点小于
<code>L</code> 时输出 <code>-1</code>.</p>
<p>注意涉及到比较和运算的变量都要设置为浮点型.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> crt=<span class="number">0</span>;<span class="comment">// 覆盖到的区间的右端点</span></span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span>(arr[<span class="number">0</span>].r&lt;L)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (crt&lt;L)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isv[i]&amp;&amp;arr[i].l&lt;crt)&#123;</span><br><span class="line">                isv[i]=<span class="number">1</span>;</span><br><span class="line">                ans++;</span><br><span class="line">                crt=arr[i].r;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123; <span class="comment">// 不存在左端点小于crt的线段</span></span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            is_out=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!is_out)</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="p2158">P2158</h1>
<p>找到满足 <span class="math inline">\(2\le x &lt; y \le n-1\land
\gcd(x,y)=1\)</span> 的 <span class="math inline">\((x,y)\)</span>
的对数, 最后结果乘2加上 <span class="math inline">\(3\)</span> 即可,
显然是转化为欧拉函数的前缀和, 最终答案为</p>
<p><span class="math display">\[
\mathtt{ans}=2\sum_{i=2}^{n-1}\varphi(n)+3
\]</span></p>
<p>用线性筛求积性函数即可, <span class="math inline">\(O(n)\)</span>. 当
<span class="math inline">\(p_j\mid i\)</span> 时, 设 $i=kp_j^{a} $,
<span
class="math inline">\(\varphi(ip_j)=\varphi(kp_j^{a+1})=\varphi(k)(p_j^{a+1}-p_j^a)=\varphi(kp_{j}^a)p_j=\varphi(i)p_j\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> phi[N],p[N],isv[N],cnt=<span class="number">0</span>,n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isv[<span class="number">1</span>]=phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isv[i])&#123;</span><br><span class="line">            p[++cnt]=i; <span class="comment">//记录素数</span></span><br><span class="line">            phi[i]=i<span class="number">-1</span>; <span class="comment">// 欧拉函数的性质</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;j++)&#123;</span><br><span class="line">            isv[i*p[j]]=<span class="number">1</span>; <span class="comment">// 筛掉</span></span><br><span class="line">            <span class="keyword">if</span>(i%p[j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                phi[i*p[j]]=phi[i]*phi[p[j]]; <span class="comment">// 如果i和p[j]互质</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                phi[i*p[j]]=phi[i]*p[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像也可以用莫比乌斯反演求 <span class="math inline">\(\displaystyle
\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}[\gcd(i,j)=1]\)</span>, <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2522">这里</a>是个更一般的题.
不会做.</p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/OS/1-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/OS/1-introduction/" class="post-title-link" itemprop="url">OS intro</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-25 11:18:46" itemprop="dateCreated datePublished" datetime="2023-07-25T11:18:46+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 11:38:36" itemprop="dateModified" datetime="2023-07-31T11:38:36+08:00">2023-07-31</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/25/OS/1-introduction/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/25/OS/1-introduction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<blockquote>
<p>希望能坚持。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/">xv6-book</a></p>
<p><a
target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">course</a></p>
<h1 id="概述">概述</h1>
<p>操作系统通过接口向用户提供服务.</p>
<p>Kernel: 一个为正在运行的程序提供服务的特殊的程序.
一台计算机只有一个内核.</p>
<p>正在运行的程序称为进程(process),
进程有包含指令、数据和堆栈的内存.</p>
<p>堆栈: 组织程序的过程调用.</p>
<p>进程调用内核服务时, 它会调用一个<strong>系统调用</strong>(system
call),
系统调用是指操作系统提供给应用程序的一组接口，用于访问操作系统的功能和资源.
它允许应用程序通过调用特殊的函数或指令请求操作系统来执行某些任务.</p>
<p>shell 是一个普通的用户程序, 不是内核的一部分,
从用户那里读取命令并执行.</p>
<p>内核提供的系统调用集合是用户程序看到的接口, 下面是 xv6 kernel
所有的系统调用.</p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>系统调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>int fork()</code></td>
<td>创建一个进程，返回子进程(已有的进程创建的进程)的PID(进程标识符)</td>
</tr>
<tr class="even">
<td><code>int exit(int status)</code></td>
<td>终止当前进程(并释放资源,
比如内存和打开的文件)，并将状态报告给wait()函数。无返回, 通常0表示成功,
1表示失败</td>
</tr>
<tr class="odd">
<td><code>int wait(int *status)</code></td>
<td>等待一个子进程退出; 将退出状态存入*status; 返回子进程PID;
如果调用者没有子进程, 立刻返回 <code>-1</code>,
若不关注子进程的退出状态, 可以直接 <code>wait((int *)0)</code>.</td>
</tr>
<tr class="even">
<td><code>int kill(int pid)</code></td>
<td>终止对应PID的进程，返回 <span
class="math inline">\(0\)</span>，或返回 <span
class="math inline">\(-1\)</span> 表示错误</td>
</tr>
<tr class="odd">
<td><code>int getpid()</code></td>
<td>返回当前进程的PID</td>
</tr>
<tr class="even">
<td><code>int sleep(int n)</code></td>
<td>暂停 <span class="math inline">\(n\)</span> 个时钟节拍</td>
</tr>
<tr class="odd">
<td><code>int exec(char *file, char *argv[])</code></td>
<td>加载一个文件并使用参数执行它; 只有在出错时才返回</td>
</tr>
<tr class="even">
<td><code>char *sbrk(int n)</code></td>
<td>给进程的内存增加 <span class="math inline">\(n\)</span>
字节。返回新内存的起始地址</td>
</tr>
<tr class="odd">
<td><code>int open(char *file, int flags)</code></td>
<td>打开一个文件；flags表示read/write；返回一个fd（文件描述符）</td>
</tr>
<tr class="even">
<td><code>int write(int fd, char *buf, int n)</code></td>
<td>从buf 写n 个字节到文件描述符fd; 返回n</td>
</tr>
<tr class="odd">
<td><code>int read(int fd, char *buf, int n)</code></td>
<td>将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0</td>
</tr>
<tr class="even">
<td><code>int close(int fd)</code></td>
<td>释放打开的文件fd</td>
</tr>
<tr class="odd">
<td><code>int dup(int fd)</code></td>
<td>返回一个新的文件描述符，指向与fd 相同的文件</td>
</tr>
<tr class="even">
<td><code>int pipe(int p[])</code></td>
<td>创建一个管道，把read/write文件描述符放在p[0]和p[1]中</td>
</tr>
<tr class="odd">
<td><code>int chdir(char *dir)</code></td>
<td>改变当前的工作目录</td>
</tr>
<tr class="even">
<td><code>int mkdir(char *dir)</code></td>
<td>创建一个新目录</td>
</tr>
<tr class="odd">
<td><code>int mknod(char *file, int, int)</code></td>
<td>创建一个设备文件</td>
</tr>
<tr class="even">
<td><code>int fstat(int fd, struct stat *st)</code></td>
<td>将打开文件fd的信息放入*st</td>
</tr>
<tr class="odd">
<td><code>int stat(char *file, struct stat *st)</code></td>
<td>将指定名称的文件信息放入*st</td>
</tr>
<tr class="even">
<td><code>int link(char *file1, char *file2)</code></td>
<td>为文件file1创建另一个名称(file2)</td>
</tr>
<tr class="odd">
<td><code>int unlink(char *file)</code></td>
<td>删除一个文件</td>
</tr>
</tbody>
</table>
<blockquote>
<p>call 和 invoke 的区别?</p>
</blockquote>
<h2 id="进程和内存">1.1 进程和内存</h2>
<p>一个进程使用系统调用 <code>fork</code> 来创建一个新的进程,
新的进程称为子进程, 其内存内容与调用它的进程(称为父进程)相同.
在父进程中, <code>fork</code> 返回子进程的PID, 在子进程中,
<code>fork</code> 返回零.</p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/OR/int-prop/lagrangian-duality/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/25/OR/int-prop/lagrangian-duality/" class="post-title-link" itemprop="url">拉格朗日对偶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-25 11:10:45" itemprop="dateCreated datePublished" datetime="2023-07-25T11:10:45+08:00">2023-07-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-03 11:52:19" itemprop="dateModified" datetime="2023-08-03T11:52:19+08:00">2023-08-03</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/25/OR/int-prop/lagrangian-duality/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/25/OR/int-prop/lagrangian-duality/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/24/OR/int-prop/valid-inequation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/24/OR/int-prop/valid-inequation/" class="post-title-link" itemprop="url">有效不等式与强有效不等式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-24 10:55:24" itemprop="dateCreated datePublished" datetime="2023-07-24T10:55:24+08:00">2023-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-29 20:42:34" itemprop="dateModified" datetime="2023-07-29T20:42:34+08:00">2023-07-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">组合优化与整数规划</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/24/OR/int-prop/valid-inequation/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/24/OR/int-prop/valid-inequation/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>设 <span class="math inline">\(X\)</span> 为单纯形与 <span
class="math inline">\(\mathbb{Z}\)</span>
的交集，定义其<strong>有效不等式</strong>为不等式 <span
class="math inline">\(\lambda^Tx\le \lambda_0\)</span> 满足 <span
class="math inline">\(\forall x\in X,\lambda^Tx\le
\lambda_0\)</span>。设 <span
class="math inline">\(\mathrm{conv}(X)\)</span> 表示 <span
class="math inline">\(X\)</span>
的凸包，显然凸包的某个方向的任意边界都是一个有效不等式。</p>
<h2 id="chvatal-gomory方法">Chvatal-Gomory方法</h2>
<p>Chvatal-Gomory方法（简称C-G方法）用于产生有效不等式。对于 <span
class="math inline">\(X=\{x:Ax\le b,x\in\mathbb{Z}^{n}_+\}\)</span>,
考虑 <span class="math inline">\(P=\{x\in\mathbb{R}^n_+:Ax\le
b\}\)</span>, 先构造 <span class="math inline">\(P\)</span>
的有效不等式，按照下面的步骤：</p>
<ol type="1">
<li>选择权值向量 <span
class="math inline">\(\mu\in\mathbb{R}^m_+\)</span>，则 <span
class="math inline">\(P\)</span>
中的不等式的线性组合即为其有效不等式，为</li>
</ol>
<p><span class="math display">\[
\sum_{j=1}^n\mu^Ta_jx_j\le\mu^Tb
\]</span></p>
<p>其中 <span class="math inline">\(A\in\mathbb{R}^{m\times
n}=(a_1,\cdots,a_n)\)</span>.</p>
<ol start="2" type="1">
<li>根据下取整的性质以及 <span class="math inline">\(x\)</span>
的正性，可以将上面有效不等式的系数做一个下取整，就有</li>
</ol>
<p><span class="math display">\[
\sum_{j=1}^n\lfloor\mu^Ta_j\rfloor x_j\le\mu^Tb
\]</span></p>
<ol start="3" type="1">
<li>由于不等式的左侧是整数，因此就有</li>
</ol>
<p><span class="math display">\[
\sum_{j=1}^n\lfloor\mu^Ta_j\rfloor x_j\le\lfloor\mu^Tb\rfloor
\]</span></p>
<p>这就是 <span class="math inline">\(X\)</span> 的一个有效不等式。</p>
<h2 id="gomory割平面法">Gomory割平面法</h2>
<p>在求出整数规划对应的线性松弛问题的解之后,
若线性松弛问题的最优解都是整数, 那么该最优解就是整数规划的最优解.
下面讨论最优解不全为整数的情况. Gomory 割平面法的思想是,
当得到的线性松弛问题的最优解不全是整数时,
想办法添加新的约束条件把该最优解排除,
而不把约束集中的原整数可行解排除(将最优解割掉).</p>
<p><strong>Gomory割平面实际上就是有效不等式.</strong></p>
<p>不妨设线性松弛问题的最优解的基在前 <span
class="math inline">\(m\)</span> 列, 即最优解可以写成 <span
class="math inline">\(\hat{x}=[b^T,0]^T\)</span> 形式. 假设 <span
class="math inline">\(b_i\)</span> 不是整数, 首先由约束条件得: <span
class="math display">\[
x_i+\sum_{j=m+1}^{n}a_{ij}x_{j}=b_i\tag{i}
\]</span> 由于 <span class="math inline">\(x\ge 0,\)</span> 故 <span
class="math display">\[
x_i+\sum_{j=m+1}^{n}\lfloor a_{ij}\rfloor x_{j}\le
x_i+\sum_{j=m+1}^{n}a_{ij}x_{j}=b_i
\]</span> 在要求解为整数的前提下, 上式左边向下取整之后不发生变化,
于是不等式两边同时向下取整就有 <span class="math display">\[
x_i+\sum_{j=m+1}^{n}\lfloor a_{ij}\rfloor x_{j}\le \lfloor b_i\rfloor
\tag{ii}
\]</span> <span class="math inline">\(\rm (i)-(ii),\)</span> 有 <span
class="math display">\[
\sum_{j=m+1}^n (a_{ij}-\lfloor a_{ij}\rfloor)x_j\ge b_i-\lfloor
b_{i}\rfloor\tag{iii}
\]</span> 由于 <span class="math inline">\(b_i\notin
\mathbb{Z},\)</span> 则 <span class="math inline">\(b_i-\lfloor
b_{i}\rfloor&gt;0,\)</span> 而显然 <span
class="math inline">\(\hat{x}\)</span> 不符合该 <span
class="math inline">\(\rm (iii)\)</span> , 因为代入 <span
class="math inline">\(\hat{x}\)</span> 之后左边为 <span
class="math inline">\(0\)</span> 而右边是一个大于 <span
class="math inline">\(0\)</span> 的数,
而对于原线性松弛问题的所有的整数可行解, 它们满足上述讨论的每一步的约束,
那么它们自然满足 <span class="math inline">\(\rm (iii),\)</span>
于是约束 <span class="math inline">\(\rm (iii)\)</span> 就称为 Gomory
割平面, 把它添加到原线性松弛问题中继续求解,
直到新得到的最优解所有的分量都为整数.</p>
<p>添加新的变量把 Gomory 割平面写成标准形式: <span
class="math display">\[
\sum_{j=m+1}^n (a_{ij}-\lfloor a_{ij}\rfloor)x_j-x_{n+1}= b_i-\lfloor
b_{i}\rfloor
\]</span> 需要注意的是, 新添加的变量并不是我们想要的变量,
它无需是整数.</p>
<p>如果最优解不在前 <span class="math inline">\(m\)</span> 列,
设最优解/基变量对应的下标集为 <span class="math inline">\(I,\)</span>
非基变量对应的下标集为 <span class="math inline">\(J,\)</span> 则 Gomory
割平面为: <span class="math display">\[
\sum_{j\in J} (a_{ij}-\lfloor a_{ij}\rfloor)x_j-x_{n+1}= b_i-\lfloor
b_{i}\rfloor
\]</span> 其中 <span class="math inline">\(i\in I,\)</span> 且满足 <span
class="math inline">\(\hat{x}_i\not\in \mathbb{Z},\)</span> 其中 <span
class="math inline">\(\hat{x}_i\)</span> 为 IP
对应的线性松弛问题最优解中的不是整数的那个.</p>
<p>如果有多个解不是整数, 可以选择每次只添加一个割平面,
也可以将所有的割平面添加进去.</p>
<h2 id="混合整数割">混合整数割</h2>
<p>上文的割平面适用于严格的整数规划问题, 对于混合整数规划问题,
它的约束集一般表述为 <span
class="math inline">\(\{x\in\mathbb{Z}_+^n,y\in\mathbb{R}_+^p:Ax+Gy\le
b,b\in\mathbb{R}^m\}\)</span>, 此时的有效不等式/割平面要复杂一些. 记记号
<span
class="math inline">\(\tilde{\cdot}=\cdot-\lfloor\cdot\rfloor\)</span>.</p>
<p><strong>定理1</strong> 设 <span
class="math inline">\(X=\left\{x\in\mathbb{Z}_+^n,y\in\mathbb{R}_+^p:\sum_{j\in
[n]}a_jx_j+\sum_{j\in[p]}g_jy_j\le
b,a_j,g_j,b\in\mathbb{R}\right\}\)</span>, 它的有效不等式为 <span
class="math display">\[
\sum_{j\in[n]}\lfloor a_j\rfloor x_j+\frac{1}{1-\tilde{b}}\sum_{j\in
J^-}g_jy_j\le \lfloor b\rfloor
\]</span> 其中 <span class="math inline">\(J^{-}=\{j\in
[p]:g_j&lt;0\}\)</span>, 同时该有效不等式为 <span
class="math inline">\(\mathrm{conv}(X)\)</span>的一个刻面.</p>
<p><strong>定理2</strong>
设通过单纯形法求解混合整数线性规划的最优解时得到的单纯形表中描述整数基变量
<span class="math inline">\(y_{B_u}\)</span> 的等式约束为 <span
class="math inline">\(X^{(B_u)}=\left\{y_{B_u}\in\mathbb{Z},x\in\mathbb{Z}_+^{n_1},y\in\mathbb{R}_+^{n_2}:y_{B_u}+\sum_{j\in
N_1}\bar{a}_{uj}y_j+\sum_{j\in N_2}\bar{a}_{uj}x_j\le
\bar{a}_{u0},\right\}\)</span>, <span class="math inline">\(N_2\)</span>
为整数非基变量下标集, <span class="math inline">\(N_2\)</span>
为实数非基变量的下标集, 那么 <span
class="math inline">\(X^{(B_u)}\)</span> 的有效不等式为 <span
class="math display">\[
\left(\sum_{\tilde{a}_j\le
\tilde{a}_0}\tilde{a}_jy_j+\sum_{\tilde{a}_j&gt;\tilde{a}_j}\frac{\tilde{a}_0(1-\tilde{a}_0)}{1-\tilde{a}_0}y_j\right)+\left(\sum_{\bar{a}_{uj}&gt;0}\bar{a}_{uj}x_j+\sum_{\bar{a}_{uj}&lt;0}\frac{\tilde{a}_0}{1-\tilde{a}_0}\bar{a}_{uj}x_j\right)
\ge \tilde{a}_0
\]</span> 这是所谓的Gomory混合整数割(平面).</p>
<blockquote>
<p>证明上述定理仅需要通过分类讨论, 取整函数的性质和不等式的基本性质即可,
要证明构造的有效不等式为凸包的刻面, 还需要找到 <span
class="math inline">\(n+p\)</span>
个仿射无关的点使有效不等式等号成立(在有效不等式平面上).</p>
</blockquote>
<h2 id="多面体理论与强有效不等式">多面体理论与强有效不等式</h2>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/20/CO/TSP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/20/CO/TSP/" class="post-title-link" itemprop="url">Heuristic Algorithms for TSP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-20 10:40:04" itemprop="dateCreated datePublished" datetime="2023-07-20T10:40:04+08:00">2023-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-14 21:16:30" itemprop="dateModified" datetime="2023-08-14T21:16:30+08:00">2023-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/20/CO/TSP/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/20/CO/TSP/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<h1 id="tsp上界">TSP上界</h1>
<p>考虑欧氏平面上的完全图 <span
class="math inline">\(G=(V,E),|V|=n\)</span>,
此时边权为正且满足三角不等式. 设最优环游为 <span
class="math inline">\(H^*\)</span>, 启发式算法产生的解记作 <span
class="math inline">\(H\)</span>, 边权 <span
class="math inline">\(c:E\to\mathbb{R}_+\)</span>.</p>
<h2 id="最近邻法">最近邻法</h2>
<p>从起点开始, 每次选择距离当前点最近的点即可. 满足 <span
class="math inline">\(c(H)\le
\frac{1}{3}\left\lceil\log_2(n+1)+\frac{4}{9}\right\rceil
c(H^*)\)</span>, 粗略点就是 <span
class="math inline">\(c(H)/c(H^*)=O(\log n)\)</span>.</p>
<p>如果图不满足三角不等式,
那么最近邻法产生的环游与最优环游的比值可以任意大.</p>
<h2 id="插入法">插入法</h2>
<h2 id="christofides-启发式方法">Christofides 启发式方法</h2>
<p>需要用到最小生成树 <span class="math inline">\(T\)</span>, 记 <span
class="math inline">\(W\)</span> 为 <span
class="math inline">\(T\)</span> 中度数为奇数的顶点的集合, 在 <span
class="math inline">\(T\)</span> 中, 由握手定理可得 <span
class="math inline">\(\sum_{v\in W}\deg(v)\)</span> 为偶数, 于是必然有
<span class="math inline">\(|W|\)</span> 为偶数, 因此诱导子图 <span
class="math inline">\(G[W]\)</span> 存在最小费用完美匹配 <span
class="math inline">\(M\)</span>, 令 <span
class="math inline">\(J=E(T)\cup M\)</span>,
在这里边集的并要求保留重复元素, 即允许出现重边, 这样得到子图 <span
class="math inline">\(G&#39;=(V,J)=T\cup (W,M)\)</span>, 显然 <span
class="math inline">\(G&#39;\)</span> 中所有点的度数均为偶数,
因为将完美匹配并入最小生成树 <span class="math inline">\(T\)</span>
中时未改变偶数度顶点的度数, 给每个奇数度顶点的度数加上了一, 于是 <span
class="math inline">\(G&#39;\)</span> 中存在欧拉圈, 设欧拉圈为 <span
class="math inline">\(v_0,\cdots,v_0\)</span>,
在欧拉圈的基础上构造TSP环游: 置 <span
class="math inline">\(H:=\emptyset\)</span>, 按照欧拉圈的顺序逐边向
<span class="math inline">\(H\)</span> 中添加边, 若在 <span
class="math inline">\(v_{i}\)</span> 时 <span
class="math inline">\(v_{i+1},\cdots,v_{j}(j\ge i+1)\)</span>
已经被访问过且 <span class="math inline">\(v_{j+1}\)</span> 未被访问过,
则置 <span class="math inline">\(H:=H\cup
\{v_{i},v_{j+1}\}\)</span>(即跳过已经被访问过的点),
直到所有顶点都被访问.</p>
<p><strong>定理1</strong> Christofides 启发式方法得到的环游满足 <span
class="math inline">\(c(H)/c(H^*)\le 3/2\)</span>.</p>
<p><strong><em>PROOF</em></strong> 由于环游 <span
class="math inline">\(H\)</span> 是在 <span
class="math inline">\(G&#39;=T\cup (W,M)\)</span> 上进行改进得到的,
只需要证明 <span class="math inline">\(c(E(G&#39;))\le
1.5c(H^*)\)</span> 即可, 分别考虑最小生成树和完美匹配的边权. 首先一定有
<span class="math inline">\(c(E(T))\le c(H^*)\)</span>, 如若不然, 去掉
<span class="math inline">\(H^*\)</span>
的一条边得到的生成树便可成为新的最小生成树; 对于 <span
class="math inline">\(W\)</span>, 按照顶点在 <span
class="math inline">\(H^*\)</span> 的顺序将 <span
class="math inline">\(W\)</span> 中的点画成一个圈 <span
class="math inline">\(C\)</span>, 由三角不等式可得 <span
class="math inline">\(c(C)\le c(H^*)\)</span>, 且圈 <span
class="math inline">\(C\)</span> 可以被划分为 <span
class="math inline">\(G[W]\)</span> 的两个完美匹配 <span
class="math inline">\(M_1,M_2\)</span>, 显然最小费用完美匹配 <span
class="math inline">\(M\)</span> 满足 <span
class="math inline">\(c(M)\le \min \{c(M_1),c(M_2)\}\le
\frac{c(M_1)+c(M_2)}{2}=c(C)/2\le c(H^*)/2\)</span>. 因此 <span
class="math inline">\(c(H)\le c(J)=c(E(T))+c(M)\le 1.5c(H^*)\)</span>.
<span class="math inline">\(\blacksquare\)</span></p>
<p>这个 <span class="math inline">\(1.5\)</span> 不能再继续减小了.</p>
<blockquote>
<p>还有一种更简单的用到最小生成树的启发式算法:
先序遍历最小生成树得到的环游可以作为一个启发式的解, 此时满足 <span
class="math inline">\(c(H)/c(H^*)\le 2\)</span>.</p>
</blockquote>
<h2 id="k-交换"><span class="math inline">\(k\)</span>-交换</h2>
<p>常用的是2-opt和3-opt.</p>
<p><span class="math inline">\(k\)</span>-opt用于改进已有的环游,
比如Chrisrofides产生的环游 <span class="math inline">\(H\)</span>. <span
class="math inline">\(2\)</span>-opt 是对 <span
class="math inline">\(H\)</span> 的不相邻的两条边做交换操作, 更详细地说,
是将这两条边删去得到两条路径 <span
class="math inline">\(H_1,H_2\)</span>, 通过一种唯一的方法将 <span
class="math inline">\(H_1,H_2\)</span> 组合成一条新的环游 <span
class="math inline">\(H&#39;\)</span>, 若 <span
class="math inline">\(c(H&#39;)&lt; c(H)\)</span>, 那我们就认为 <span
class="math inline">\(H&#39;\)</span> 是更优的选择.
最终可以达到一个最优的状态, 即不能再通过2-交换得到更优的环游.
3-交换是类似的操作, 删边-重新组合. 当 <span
class="math inline">\(k&gt;3\)</span> 时,
删边重新组合成新的环游的方法数呈指数级上升, 一般不采用.</p>
<p>遗憾的是虽然可以在 <span class="math inline">\(O(|V|^2)\)</span>
内验证一条环游是否是2-opt的,
但是有可能需要指数次交换才能将任意一条环游变为2-opt的.</p>
<h2 id="lin-kernighan">Lin-Kernighan</h2>
<p>Lin-Kernighan启发式方法简称为LKH,
是目前最高效的TSP启发式算法之一。</p>
<p>首先需要定义 <span
class="math inline">\(\delta\)</span>-path相关的概念. <span
class="math inline">\(\delta\)</span>-path是一条path满足path的终点是路径上的某个点,
也就是说 <span class="math inline">\(\delta\)</span>-path中含有一个圈,
如下图的 <span class="math inline">\(P\)</span> 所示, 其中 <span
class="math inline">\(w\)</span> 为该路径的终点(当然也在路径中出现过),
<span class="math inline">\(r\)</span> 为 <span
class="math inline">\(w\)</span> 紧跟着的点.</p>
<p>可以通过一个 <span class="math inline">\(\delta\)</span>-path
构造一个TSP环游, 构造规则为: 将路径终点所在的路径中的</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/20230721201048.png" /></p>
<p>LKH算法的核心思想就是不断通过删边与加边构造费用越来越小的 <span
class="math inline">\(\delta\)</span>-path.</p>
<p><a
target="_blank" rel="noopener" href="https://stemlounge.com/animated-algorithms-for-the-traveling-salesman-problem/">11
Animated Algorithms for the Traveling Salesman Problem
(stemlounge.com)</a></p>
<h1 id="tsp下界">TSP下界</h1>
<h2 id="held-karp-bound">Held-Karp bound</h2>
<p>对于任意一个环游 <span class="math inline">\(H\subset E\)</span>,
一个相当 trivial 的下界可以由下面的方式找到:</p>
<p>对于 <span class="math inline">\(v_1\in V\)</span>, 设 <span
class="math inline">\(e,f\)</span> 是以 <span
class="math inline">\(v_1\)</span> 为端点的两条不同的边, 令 <span
class="math inline">\(P=T\backslash\{e,f\}\)</span>, 那么就有 <span
class="math inline">\(c(H)=c(P)+c_e+c_f\)</span>, 倘若有 <span
class="math display">\[
\begin{cases}
A\le c_e+c_f\\
B\le c(P)
\end{cases}
\]</span> 那么 <span class="math inline">\(A+B\)</span> 自然就是环游
<span class="math inline">\(H\)</span> 费用的一个下界.</p>
<p>那么该如何找到这样的 <span class="math inline">\(A,B\)</span> 呢?
<span class="math inline">\(A\)</span> 是相当好找的, 找到费用最小的以
<span class="math inline">\(v_1\)</span> 为端点的两条边即可. 对于 <span
class="math inline">\(B\)</span>, 首先 <span
class="math inline">\(P\)</span> 是 <span
class="math inline">\(G\backslash\{v_1\}\)</span> 的一棵生成树, 那么显然
<span class="math inline">\(G\backslash\{v_1\}\)</span>
的最小生成树的费用可以作为下界 <span class="math inline">\(B\)</span>,
上面这样的 <span class="math inline">\(A+B\)</span> 称为 <strong>1-tree
bound</strong>.</p>
<blockquote>
<p>为何不直接用 <span class="math inline">\(G\)</span>
的最小生成树的费用来作为下界呢? 上面的方法是否可以获得更紧的下界呢?</p>
</blockquote>
<p>这个界还可以改善, 比如下面的例子中的 1-tree bound 是 <span
class="math inline">\(0\)</span>, 这是一个相当平凡的值,
出现这种原因是因为有三条边权为 <span class="math inline">\(0\)</span>
的点与点 <span class="math inline">\(u\)</span> 相连,
这意味着这三条边在最小生成树中一定会出现, 为了改善这种情况,
可以考虑修改边权而不改变最优环游的位置(当然其实我们不关注修改后的最优环游,
关注的是修改后的 1-tree bound). 可以将以 <span
class="math inline">\(u\)</span> 为端点的边的权重都加 <span
class="math inline">\(10\)</span>, 那么下界将变为 <span
class="math inline">\(30\)</span> 而最优环游并不发生变化.</p>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308142038469.png" style="zoom:50%;" /></p>
<p>下面形式化地叙述 Held-Karp bound 的计算过程:</p>
<p><strong>定理1 (Held-Karp bound)</strong> 设原始费用函数为 <span
class="math inline">\(c: E\to\mathbb{R_{\ge 0}}\)</span>, 对于任意 <span
class="math inline">\(v\in V\)</span> 和 <span
class="math inline">\(\mathbf{y}=(\cdots,y_v,\cdots)\in\mathbb{R}^{|V|}\)</span>
, 给顶点 <span class="math inline">\(v\)</span> 分配一个实数 <span
class="math inline">\(y_v\)</span>, 将以顶点 <span
class="math inline">\(v\)</span> 为顶点的边的费用都减少 <span
class="math inline">\(y_v\)</span>, 得到一个新的费用函数为 <span
class="math inline">\(c&#39;\)</span>(即对任意 <span
class="math inline">\((u,v)\in E,c&#39;(u,v)=c(u,v)-y_u-y_v\)</span>) ,
令 <span class="math inline">\(C\)</span> 为 <span
class="math inline">\(G\)</span> 关于费用 <span
class="math inline">\(c&#39;\)</span> 的一个 1-tree bound, 那么 <span
class="math inline">\(2\sum_{v\in V}y_v+C\)</span> 是 <span
class="math inline">\(G\)</span> 关于费用 <span
class="math inline">\(c\)</span> 的最优环游的费用的下界. <span
class="math inline">\(\square\)</span></p>
<p>如何寻找合适的 <span class="math inline">\(\mathbf{y}\)</span>? Held
和 Karp 给出了一个迭代策略: 设 <span
class="math inline">\(y_{v}^{(k)}\)</span> 表示第 <span
class="math inline">\(k\)</span> 轮迭代赋予的值, 首先初始化 <span
class="math inline">\(\mathbf{y}^{(0)}\)</span> 同时得到一棵初始的
1-tree bound 对应的子图 <span class="math inline">\(T_0\)</span>, 接着设
<span class="math inline">\(d_{T_k}(v)\)</span> 表示 <span
class="math inline">\(T_k\)</span> 中顶点 <span
class="math inline">\(v\)</span> 的度数, 那么 <span
class="math inline">\(y_v^{(k+1)}=y_v^{(k)}+t(2-d_T(v))\)</span>,
其中实数 <span class="math inline">\(t\)</span> 为一个固定的步长.
步长也可以做启发式的更改, 迭代公式可以写为 <span
class="math inline">\(y_v^{(k+1)}=y_v^{(k)}+t_k(2-d_{T_k}(v))\)</span>,
其中 <span class="math display">\[
t_k=\frac{\alpha_k(U-L_{\text{H-K}}^{(k)})}{\sum_{v\in V}
(2-d_{T_k}(v))^2}
\]</span> 其中 <span class="math inline">\(U\)</span> 是一个 TSP 上界,
可以由前述的启发式算法得到, <span
class="math inline">\(L_{\text{H-K}}^{(k)}\)</span> 是当前的 Held-Karp
bound, <span class="math inline">\(\alpha_k\)</span> 是一个在 <span
class="math inline">\((0,2]\)</span> 的实数, 可以令 <span
class="math inline">\(\alpha_0=2\)</span> 并使序列以固定的步长减少,
这个数取决于顶点数目以及我们愿意花费的时间.</p>
<p>可以证明固定步长的迭代会收敛到一个最优 Held-Karp 界对应的 <span
class="math inline">\(\mathbf{y}\)</span>,
但这个收敛时间可能是指数级别的, 同时并不是每次迭代获得的 <span
class="math inline">\(\mathbf{y}\)</span> 都改善当前的 Held-Karp 界,
可能会获得更糟糕的界.</p>
<p>可以使用线性规划获得与 Held-Karp bound 完全等价的bound.</p>
<h2 id="线性规划下界技术">线性规划下界技术</h2>
<h1 id="tsp的一个dp算法">TSP的一个DP算法</h1>
<p>设 <span class="math inline">\(V=\{c_1,\cdots,c_n\}\)</span>,
考虑到环游中起点的任意性, 以 <span class="math inline">\(c_1\)</span>
为起点. 对非空集合 <span class="math inline">\(S\subset
\{c_2,\cdots,c_n\}\land c_i\in S\)</span>, 设 <span
class="math inline">\(f(S,c_i)\)</span> 表示以 <span
class="math inline">\(c_1\)</span> 为起点 <span
class="math inline">\(c_i\)</span> 为终点且经过 <span
class="math inline">\(S\)</span> 中所有点的最短路径, 首先 <span
class="math inline">\(|S|=1\)</span> 时 <span
class="math inline">\(f(S,c_i)=f(\{c_i\},c_i)=d(c_1,c_i)\)</span>; 当
<span class="math inline">\(|S|&gt;1\)</span> 时, 只需枚举 <span
class="math inline">\(c_i\)</span> 的前置结点 <span
class="math inline">\(c_j(j\ne i)\)</span>, 此时终止于 <span
class="math inline">\(c_j\)</span> 的最短路径对应的 <span
class="math inline">\(f\)</span> 可以表示为 <span
class="math inline">\(f(S\backslash\{c_i\},c_j)\)</span>, 那么就有 <span
class="math display">\[
f(S,c_i)=\min_{c_j\in
S\backslash\{c_i\}}f(S\backslash\{c_i\},c_j)+d(c_j,c_i)
\]</span> 最终最优环游为 <span class="math inline">\(\min_{2\le i\le
n}f(\{c_2,\cdots,c_n\},c_i)+d(c_i,c_1)\)</span>. 这个动态规划的复杂度为
<span
class="math inline">\(\sum_{k=1}^{n-1}O\left(\binom{n}{k}k^2\right)=O(n^22^n)=O^*(2^n)\)</span>,
<span class="math inline">\(O^*(b^n)=O(b^np(n))\)</span>其中 <span
class="math inline">\(p(n)\)</span> 为多项式.</p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/10/OR/int-prop/well-solved/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/10/OR/int-prop/well-solved/" class="post-title-link" itemprop="url">Well-Solved Problems</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-10 17:09:44" itemprop="dateCreated datePublished" datetime="2023-07-10T17:09:44+08:00">2023-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-29 20:42:47" itemprop="dateModified" datetime="2023-07-29T20:42:47+08:00">2023-07-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">组合优化与整数规划</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/10/OR/int-prop/well-solved/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/10/OR/int-prop/well-solved/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>699</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>这部分介绍一些已经解决得很好的组合优化问题, 在此之前,
需要先定义什么叫做"解决得很好".</p>
<p>对于给定的组合优化问题 <span class="math inline">\(\max\{c^Tx:x\in
X\subset\mathbb{R}^n\}\)</span>,
定义与其相伴的<strong>分离问题</strong>为: 给定一个点 <span
class="math inline">\(x^{\ast}\)</span>, 判断 <span
class="math inline">\(x^{\ast}\in\mathrm{conv}(X)\)</span> 是否成立,
若不成立, 找到一个超平面将 <span class="math inline">\(x^{\ast}\)</span>
和 <span class="math inline">\(x^{\ast}\in\mathrm{conv}(X)\)</span>
分离开来, 说的更具体一点, 要找到 <span class="math inline">\(a^Tx\le
a_0\)</span> 对任意 <span class="math inline">\(x\in X\)</span> 都成立但
<span class="math inline">\(a^Tx^{\ast}&gt;a_0\)</span>.</p>
<p>在判断一个问题是否有高效的算法的时候,
通常会同时用到下面的四个性质:</p>
<ul>
<li>efficient optimization性质:
对于给定的组合优化问题族存在高效的(多项式)算法.</li>
<li>强对偶性质: 对于给定的问题族,
存在可以让我们得到可以快速验证最优条件的强对偶问题 <span
class="math inline">\((D):\min\{\omega(u):u\in U\}\)</span>,
这个验证解的最优条件是: <span class="math inline">\(x^{\ast}\in
X\)</span> 是原问题 <span class="math inline">\(P\)</span>
的最优解当且仅当存在 <span class="math inline">\(u^{\ast}\in U\)</span>
使得 <span
class="math inline">\(c^Tx^{\ast}=\omega(u^{\ast})\)</span>.</li>
<li>efficient separation性质:
存在与组合优化问题相伴的分离问题的高效算法.</li>
<li>精确凸包性质: 原文中有compact description of convex hull,
不知道是什么意思, 反正就是原则上可以将每个实例替换为线性规划问题 <span
class="math inline">\(\max\{cx:x\in\mathrm{conv}(X)\}\)</span>.</li>
</ul>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/03/thesis/rho-ring-star/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/03/thesis/rho-ring-star/" class="post-title-link" itemprop="url">rho-ring-star.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-03 23:18:39" itemprop="dateCreated datePublished" datetime="2023-07-03T23:18:39+08:00">2023-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-19 17:23:39" itemprop="dateModified" datetime="2023-07-19T17:23:39+08:00">2023-07-19</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/03/thesis/rho-ring-star/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/03/thesis/rho-ring-star/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<h1 id="robust-ring-star-problem">Robust Ring-Star Problem</h1>
<h2 id="definition-of-ring-star-problem">Definition of Ring-Star
Problem</h2>
<p>对于混合图<span class="math inline">\(G=(V,E\cup A)\)</span>, 设<span
class="math inline">\(V=[n]\)</span>, 顶点<span
class="math inline">\(1\)</span>表示depot, 无向边集<span
class="math inline">\(E=\{(i,j)\in V^2:i&lt;j\}\)</span>, 有向边集<span
class="math inline">\(A=V^2\)</span>.</p>
<p>Ring-Star problem分为ring part和star part,
即需要构造一个包括下面两部分的网络:</p>
<ul>
<li>ring part: 从 <span class="math inline">\(V\)</span> 中选出一个子集
<span class="math inline">\(H\)</span> 作为hub的集合,
用无向边连接选出的所有的hub构成一个cycle. 打开hub <span
class="math inline">\(i\)</span> 的代价为<span
class="math inline">\(o_i\in\mathbb{R}_{+}\)</span>; 连接hub <span
class="math inline">\(i\)</span> 和hub <span
class="math inline">\(j\)</span> 的代价为<span
class="math inline">\(r_{ij}\in\mathbb{R}_+\)</span>, 保证depot在<span
class="math inline">\(H\)</span>中.</li>
<li>star part: 除了hub以外的顶点作为terminal, 记作 <span
class="math inline">\(T=V\backslash H\)</span>, 保证terminal必须恰好与
<span class="math inline">\(H\)</span>
中的<strong>一个</strong>hub使用有向边相连(由terminal指向hub), 对于
<span class="math inline">\(t\in T,h\in H\)</span>, 连接 <span
class="math inline">\(t,h\)</span> 的代价为<span
class="math inline">\(s_{th}\in\mathbb{R}_+\)</span>.
即构造星型拓扑.</li>
</ul>
<p>RSP的目的就是最小化构造Ring-Star网络的代价.</p>
<p>上述定义中的“一个terminal必须恰好与一个hub连接”可以推广为 <span
class="math inline">\(k\)</span> 个, 表示 <span
class="math inline">\(k\)</span> edge-connected,
即每两个terminal之间恰有 <span class="math inline">\(k\)</span>
条path.</p>
<p>RSP是NP-hard的, 如果assignment cost <span
class="math inline">\(\gg\)</span> ring cost,
那么TSP将是RSP的一个特例.</p>
<h2 id="robust-rsp">Robust RSP</h2>
<p>Robust RSP记作<span class="math inline">\(\rho\)</span>-RSP,
相比RSP增加一个输入<span class="math inline">\(\widetilde{V}\subseteq
V\)</span>表示如果<span class="math inline">\(v\in\widetilde{V}\)</span>
被选中作为hub, 那么它是不稳定的, 即可能会fail, 于是为了保证网络的健壮性,
需要将不稳定的hub的neighbors相连.</p>
<h2 id="ilp表述">ILP表述</h2>
<h3 id="notation">Notation</h3>
<ul>
<li><span class="math inline">\(r_{ij}\)</span> 表示连接hub <span
class="math inline">\(i,j\)</span> 的花费</li>
<li><span class="math inline">\(x_{ij}\)</span>
用来描述不考虑hub的不稳定性时hub之间是否有边相连,
由于hub之间相连构成的子图是一个无向图, 因此约定 <span
class="math inline">\(i&lt;j\)</span>.</li>
<li><span class="math inline">\(y_{ij}\)</span> 表示是否将terminal <span
class="math inline">\(i\)</span> 连到hub <span
class="math inline">\(j\)</span> 上, 保证 <span
class="math inline">\(i\ne j\)</span>.</li>
<li><span class="math inline">\(y_{ii}\)</span> 为 <span
class="math inline">\(0\)</span> 是表示结点 <span
class="math inline">\(i\)</span> 为termianl, 为 <span
class="math inline">\(1\)</span> 表示结点 <span
class="math inline">\(i\)</span> 是 hub.</li>
<li><span class="math inline">\(x_{ik}&#39;\)</span>
表示考虑hub的不稳定时, 若 <span
class="math inline">\(\exists\tilde{v}\in\widetilde{V},\text{s.t.
}\tilde{v}\in N(i)\cap N(k)\)</span>, 则 <span
class="math inline">\(x_{ik}=1\)</span>, 否则为 <span
class="math inline">\(0\)</span>.</li>
</ul>
<p>下面是问题的ILP描述: <span class="math display">\[
\begin{aligned}
&amp;\min \sum_{i\in V}\sum_{j\in V\land i&lt;j}
r_{ij}(x_{ij}+x_{ij}&#39;)+\sum_{i\in V}o_iy_{ii}+\sum_{i\in
V}\sum_{j\in V\backslash\{i\}}s_{ij}y_{ij}
\end{aligned}
\]</span> 下面一一叙述优化问题的约束条件:</p>
<ul>
<li>首先需要保证所有的hub恰好形成一个环, 于是每个hub的度数应恰好为 <span
class="math inline">\(2\)</span>, 于是对任意 <span
class="math inline">\(i\)</span>, 都有 <span
class="math inline">\(\sum_{j\in V\land i&lt;j}x_{ij}+\sum_{j\in V\land
i&gt;j}x_{ji}=2y_{ii}\)</span></li>
<li>保证最终的RS网络只有一个hub形成的环, 而不会出现孤立的环, 考虑subtour
elimination, 对任意 <span class="math inline">\(V\)</span> 的子集 <span
class="math inline">\(S\)</span>, 有 <span
class="math inline">\(\sum_{i\in S}\sum_{j\in S\land i&lt;j}x_{ij}\le
|S|-1\)</span>, 但是如果所有的hub都在 <span
class="math inline">\(S\)</span> 里. 那么上述约束的和式可以取到 <span
class="math inline">\(|S|\)</span>, 考虑将不等式右边的 <span
class="math inline">\(1\)</span> 改为 <span
class="math inline">\(\frac{1}{|V\backslash S|}\sum_{i\in V\backslash
S}y_{ii}\in [0,1]\)</span>, 于是得到最终的subtour elimination: <span
class="math inline">\(\sum_{i\in S}\sum_{j\in S\land i&lt;j}x_{ij}\le
|S|-\frac{1}{|V\backslash S|}\sum_{i\in V\backslash S}y_{ii}\)</span>.
在实际问题中hub和terminal的数量应合理, 这里设置成 <span
class="math inline">\(|S|\le| V|/2\)</span>.</li>
<li>保证每个terminal要么与一个稳定的hub连接, 要么与两个不稳定的hub连接,
于是对任意结点 <span class="math inline">\(i\)</span> 都有 <span
class="math inline">\(\sum_{j\in V\backslash{\widetilde{V}}\land i\ne
j}y_{ij}+\frac{1}{2}\sum_{j\in\widetilde{V}\land i\ne
j}y_{ij}=1-y_{ii}\)</span>. 上个式子保证了如果结点 <span
class="math inline">\(i\)</span> 是hub则 <span
class="math inline">\(y_{ii}=1\)</span> 则对任意 <span
class="math inline">\(j\)</span> 都有 <span
class="math inline">\(y_{ij}=0\)</span>.</li>
<li>由于最小的环需要有三个边, 且若存在不稳定的hub,
则最终的RS网络的hub形成的子图应至少有4条边, 于是设置一个 <span
class="math inline">\(\sigma\)</span>, 那么有 <span
class="math inline">\(\sum_{i\in V}\sum_{j\in V\land i&lt;j}x_{ij}\ge
\sigma+3,\)</span> 其中 <span class="math inline">\(\sigma \ge
y_{ii},\forall i\in \widetilde{V}\)</span>.</li>
<li>与同一个不稳定的hub相连的两个hub需要增加一条边来确保稳定性, 对 <span
class="math inline">\(j\in\widetilde{V}\)</span>, <span
class="math inline">\(i\in V, k\in V, i&lt;j\)</span>, 若 <span
class="math inline">\(i,k\)</span>都与 <span
class="math inline">\(j\)</span> 相连, 则应有 <span
class="math inline">\(x_{ik}&#39;=1\)</span>, 于是 <span
class="math inline">\(x_{ik}&#39;\ge x_{ij}+x_{jk}-1\)</span>.</li>
<li>不需要将任何terminal或者hub连接terminal上, 于是 <span
class="math inline">\(y_{ij}\le y_{jj},\forall i\ne j\)</span>.
这保证了若 <span class="math inline">\(y_{jj}=0\)</span> 即结点 <span
class="math inline">\(j\)</span> 为terminal, 则 <span
class="math inline">\(y_{ij}=0\)</span>.</li>
<li>还有其他简单的约束, 包括将第一个点作为depot: <span
class="math inline">\(y_{11}=1\)</span>,
以及各个变量为01变量的约束.</li>
</ul>
<h2 id="使用benders-decomposition">使用Benders Decomposition</h2>
<h2 id="子问题的对偶问题">子问题的对偶问题</h2>
<h2 id="一个算法">一个算法</h2>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/05/ML/ml-regresion-and-clar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/05/ML/ml-regresion-and-clar/" class="post-title-link" itemprop="url">机器学习（1）：回归与分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-05 17:56:10" itemprop="dateCreated datePublished" datetime="2023-01-05T17:56:10+08:00">2023-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-30 23:04:16" itemprop="dateModified" datetime="2023-07-30T23:04:16+08:00">2023-07-30</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/01/05/ML/ml-regresion-and-clar/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/05/ML/ml-regresion-and-clar/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<!-- $$
\newcommand{\mb}{\mathbf}
\newcommand{\eps}{\varepsilon}
\newcommand{\bar}{\overline}
\newcommand{\boldsymbol}{\boldsymbol}
$$ -->
<p>这部分与数理统计中的多元线性回归（最小二乘法），一些优化迭代算法以及简单的矩阵微分有重叠，比较简单，主要引入了一些概念，不过也是新瓶装旧酒，没什么新的东西。</p>
<h2 id="术语与记号含义">术语与记号含义</h2>
<p><span class="math inline">\(x\)</span> 为输入变量或特征(features),
<span class="math inline">\(y\)</span> 为输出变量.</p>
<p>训练集(training set): <span
class="math inline">\(\mathcal{T}=\{(x^{(i)},y^{(i)}):i=1,\cdots,m
\},\)</span> 输入集 <span class="math inline">\(\cal X,\)</span> 输出集
<span class="math inline">\(\cal Y.\)</span></p>
<p>监督学习(supervised learning)问题实际上是: 给定训练集,
通过学习得到映射 <span class="math inline">\(h:\cal X\to Y,\)</span>
使得 <span class="math inline">\(h(x)\)</span> 能够很好地对 <span
class="math inline">\(y\)</span> 进行预测, <span
class="math inline">\(h\)</span> 又被称为假设(hypothesis).</p>
<p>如果 <span class="math inline">\(Y\)</span> 是连续集/不可列, 那么确定
<span class="math inline">\(h\)</span>
的过程称为<strong>回归</strong>(regression)问题; 如果 <span
class="math inline">\(Y\)</span> 是离散集/可列, 那么确定 <span
class="math inline">\(h\)</span>
的过程称为<strong>分类</strong>(classification)问题.
本部分将解决线性回归问题与二元分类问题.</p>
<blockquote>
<p>训练集实际上就是样本的集合捏</p>
</blockquote>
<p>自然对数用 <span class="math inline">\(\log\)</span> 而不是 <span
class="math inline">\(\ln.\)</span></p>
<h3 id="和概率论中的记号区分">和概率论中的记号区分</h3>
<p>这部分会出现很多概率论中的东西, 一些记号做如下修改:</p>
<ul>
<li>密度函数用 <span class="math inline">\(p(x;\theta)\)</span> 而不是
<span class="math inline">\(f(x;\theta)\)</span></li>
<li>01分布/伯努利分布 <span class="math inline">\(B(1,p)\)</span> 的参数
<span class="math inline">\(p\)</span> 写成 <span
class="math inline">\(\phi,\)</span> 为了与概率密度做区分,
伯努利分布记作 <span
class="math inline">\(\mathrm{Bernoulli}(\phi),\)</span> 太长了,
还是用二项分布的记号简记为 <span
class="math inline">\(B(1,\phi)\)</span> 吧.</li>
<li>随机变量不再用大写字母, 当说某个依赖于参数的随机变量服从某个分布时,
参数写明, 以正态分布为例, 写成 <span class="math inline">\(x;\theta\sim
N(\mu,\sigma^2),\)</span> 如果是条件分布, 比如在随机变量 <span
class="math inline">\(x\)</span> 已知的条件下 <span
class="math inline">\(y\)</span> 服从正态分布, 则写成 <span
class="math inline">\(y|x;\theta\sim N(\mu,\sigma^2).\)</span></li>
</ul>
<h2 id="线性回归">线性回归</h2>
<p>线性函数的形式较为简单且性质较好, 是我们常常研究的对象, 此时 <span
class="math inline">\(h(x)\)</span> 具有 <span
class="math inline">\(h_{\theta}(x)=\theta_0+\theta_1x_1+\cdots+\theta_nx_n\)</span>
的形式, 就像<a href="">多元线性回归</a>那样, 为了简便令 <span
class="math inline">\(x=(x_0,x_1,\cdots,x_n)\in\mathbb{R}^{n+1},x_0=1,\theta=(\theta_0,\cdots,\theta_n)\in\mathbb{R}^{n+1},\)</span>
于是就有 <span class="math display">\[
h_{\theta}(x)=\theta^Tx
\]</span> 对于给定 <span class="math inline">\(\cal T,\)</span> 要确定
<span class="math inline">\(\theta,\)</span>
采用的方法和多元线性回归基本一致,
在这里是选择使<strong>代价函数</strong>(cost function)值最小的参数 <span
class="math inline">\(\theta,\)</span> 即下面的优化问题 <span
class="math display">\[
\begin{aligned}
&amp;\min J(\theta)=\frac{1}{2}\sum_{i=1}^m(\theta^Tx^{(i)}-y^{(i)})^2\\
\text{s.t. }&amp;\theta\in\mathbb{R}^{n+1}
\end{aligned}
\]</span></p>
<blockquote>
<p>在多元线性回归部分, <span class="math inline">\(Q(\theta)\)</span>
并无系数 <span class="math inline">\(1/2,\)</span> 这里加上 <span
class="math inline">\(1/2\)</span> , 可以在求导的时候系数不出现 <span
class="math inline">\(2,\)</span> 并无大碍.</p>
</blockquote>
<p>多元线性回归部分已经给出了该问题的闭式解(又称为normal equations):
<span
class="math inline">\(\theta=(X^TX)^{-1}X^T\boldsymbol{y},\)</span>
这里的 <span class="math inline">\(X,\boldsymbol{y}\)</span>
与多元线性回归的 <span class="math inline">\(X,Y\)</span> 含义基本一致,
表达也相同, 注意大小写即可. 在多元线性回归部分同样给出了<a
href="">为什么最小二乘法采用平方而不是四次方之类的</a>原因.
这部分不再赘述, 下面介绍用优化算法求解上述优化问题的做法.</p>
<h3 id="借助最速下降法求解">借助最速下降法求解</h3>
<p>根据<a href="">最速下降法</a>的迭代公式: <span
class="math display">\[
\begin{aligned}
&amp;x_{k+1}=x_k-\alpha_kg_k\\
&amp;g_k=\nabla f(x)\\
&amp;\alpha_k=\arg\min_{\alpha&gt;0}f(x_k-\alpha g_k)
\end{aligned}
\]</span> 在这里, 迭代过程中要执行赋值语句 <span class="math display">\[
\theta_j:=\theta_j-\alpha \frac{\partial J}{\partial \theta_j},\forall
j=0,\cdots,n
\]</span> 其中步长 <span class="math inline">\(\alpha\)</span>
又被称为学习率(learning rate), 且 <span class="math display">\[
\begin{aligned}
\frac{\partial J}{\partial \theta_j}
&amp;=\frac{\partial }{\partial
\theta_j}\frac{1}{2}\sum_{i=1}^m(\theta^Tx^{(i)}-y^{(i)})^2\\
&amp;=\sum_{i=1}^m(\theta^Tx^{(i)}-y^{(i)})x_{j}^{(i)}
\end{aligned}
\]</span> 于是迭代公式为 <span class="math display">\[
\boxed{\theta_j:=\theta_j-\alpha\sum_{i=1}^m(\theta^Tx^{(i)}-y^{(i)})x_{j}^{(i)},\forall
j=0,\cdots,n}
\]</span></p>
<blockquote>
<p>CS229的notes里给出的是固定步长而不是最优步长.</p>
</blockquote>
<h3 id="随机梯度下降sgd">随机梯度下降SGD</h3>
<p>上面这种梯度下降法又被称为batch gradient descent,
每次迭代都需要遍历整个训练集 <span class="math inline">\(\cal
T,\)</span> 当 <span class="math inline">\(\#\cal T=m\)</span>
不太大时这种方法是行之有效的且收敛的, 但是 <span
class="math inline">\(m\)</span> 太大的时候这种方式显然代价太高,
此时随机算法就有更大的优势. 随机梯度下降(stochastic gradient descent,
SGD)每次只</p>
<h3 id="局部加权回归locally-weighted-regression">局部加权回归(locally
weighted regression)</h3>
<p>局部加权回归的思想是, 在求 <span
class="math inline">\(h_{\theta}(x)\)</span> 时更关注 <span
class="math inline">\(x\)</span> 附近的训练样本,
即让这部分在代价函数中的占比更大, 而远离 <span
class="math inline">\(x\)</span> 的那部分训练样本占比变小一些,
于是给每一项增加权重 <span class="math inline">\(w^{(i)},\)</span>
代价函数修改为 <span class="math display">\[
J(\theta)=\sum_{i=1}^mw^{(i)}(y^{(i)}-\theta^Tx^{(i)})^2
\]</span> 其中 <span class="math display">\[
w^{(i)}=\exp\left(-\frac{\|x^{(i)}-x\|^2}{2\tau^2} \right),
\]</span> 是 <span class="math inline">\(x\)</span> 的函数, 保证在确定
<span class="math inline">\(h_{\theta}(x)\)</span>
的时候将重点放在要预测的值得附近. 容易看出 <span
class="math inline">\(\|x^{(i)}-x\|\to 0\)</span> 时 <span
class="math inline">\(w^{(i)}\to 1,\)</span> 而 <span
class="math inline">\(\|x^{(i)}-x\|\to \infty\)</span> 时 <span
class="math inline">\(w^{(i)}\to 0,\)</span>
这权重的设置符合我们的预期.</p>
<blockquote>
<p><span class="math inline">\(w^{(i)}\)</span>
的形式很像正态分布的概率密度(不过两者并无直接关系), 参数 <span
class="math inline">\(\tau\)</span> 被称为bandwidth参数,
大小会影响权重的分布导致过拟合 (overfit) 或你和不足 (underfit),
具体如何影响的细节见习题.</p>
<p><span class="math inline">\(w^{(i)}\)</span> 的另一种形式是 <span
class="math display">\[
w^{(i)}=\exp\left(-\frac{1}{2}(x^{(i)}-x)^T\Sigma^{-1}(x^{(i)}-x)
\right),
\]</span> 其中 <span class="math inline">\(\Sigma \in
\mathbb{R}^{(n+1)\times (n+1)}\)</span> 是可逆矩阵.</p>
</blockquote>
<p><strong>参数学习算法(parametric learning
algorithm)与非参数学习(non-parametric learning algorithm)</strong>:</p>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="分类与-logistic-回归">分类与 logistic 回归</h2>
<p>分类问题中最简单的一种就是 <span class="math inline">\(\#
Y=2\)</span> 即二元分类的情形, 此时 <span
class="math inline">\(Y\)</span> 可以表示为 <span
class="math inline">\(\{0,1\},\{+,-\}\)</span> 等等集合, <span
class="math inline">\(0\)</span> 被称为 negtive class, <span
class="math inline">\(1\)</span> 被称为 positive class.</p>
<p>离散的问题往往不是那么好处理,
于是我们希望将二元分类问题转化为连续的问题并用回归的方式来解决.
单位阶跃函数 <span class="math inline">\(y=\delta(x)\)</span> 满足值为
<span class="math inline">\(0,1\)</span> 但不好处理,
一个方案是选择其他形状与其相似的连续函数并采用四舍五入的处理, sigmond
函数 <span class="math inline">\(\displaystyle
g(z)=\frac{1}{1+\mathrm{e}^{-z}}\in(0,1)\)</span> 是一个很好的选择,
同时我们想利用线性回归得到的 <span
class="math inline">\(\theta^Tx\in\mathbb{R},\)</span> 毕竟 sigmond
函数只有在 <span class="math inline">\(z&gt;0\)</span> 时 <span
class="math inline">\(&gt;0.5,\)</span> <span
class="math inline">\(z&lt;0\)</span> 时 <span
class="math inline">\(&lt;0.5,\)</span> <span
class="math inline">\(y\)</span> 与 <span
class="math inline">\(x\)</span> 显然不会满足这种关系,
于是可以可以构造代价函数为 <span class="math display">\[
h_{\theta}(x)=g(\theta^Tx)=\frac{1}{1+\mathrm{e}^{-\theta^Tx}}
\]</span> 下面根据代价函数确定参数 <span
class="math inline">\(\theta.\)</span></p>
<p>由于最小二乘法与 MLE 在求解参数 <span
class="math inline">\(\theta\)</span> 时是一脉相承的,
因此在这里我们将使用 MLE 确定参数 <span
class="math inline">\(\theta\)</span>
(毕竟最小二乘法仅仅适用于线性回归), 需要构造概率密度. 由于 <span
class="math inline">\(h_{\theta}(x)\in(0,1),\)</span> 不妨设 <span
class="math inline">\(P(y=1|x;\theta)=h_{\theta}(x),\)</span> 则 <span
class="math inline">\(P(y=0|x;\theta)=1-h_{\theta}(x).\)</span></p>
<blockquote>
<p>这里采用了条件概率的记号 <span
class="math inline">\(P(y=1|x;\theta),\)</span> 因为 <span
class="math inline">\(y\)</span> 的值是依赖于 <span
class="math inline">\(x\)</span> 的, 而其中使用了分号 <span
class="math inline">\(;\)</span> 而不是逗号, 是因为 <span
class="math inline">\(\theta\)</span> 是参数而非随机变量,
如果使用逗号的话, 写在 <span class="math inline">\(|\)</span>
的后面就认为 <span class="math inline">\(\theta\)</span>
也是随机变量了.</p>
</blockquote>
<p>为了在计算过程的简便, 将这两种情况合并, 可以将 <span
class="math inline">\(y\)</span> 的条件概率密度 <span
class="math inline">\(p(y|x;\theta)=h_{\theta}(x)^{y}(1-h_{\theta}(x))^{1-y},\)</span>
于是在训练集样本相互独立的条件下, 似然函数 <span class="math display">\[
L(\theta)=\prod_{i=1}^m
h_{\theta}(x^{(i)})^{y^{(i)}}(1-h_{\theta}(x^{(i)}))^{1-y^{(i)}}
\]</span> 为了便于求导取对数: <span class="math display">\[
\begin{aligned}
\ell(\theta)
&amp;=\log L(\theta)\\
&amp;=\sum_{i=1}^m
-(1-y^{(i)})\theta^Tx^{(i)}-\log(1+\mathrm{e}^{-\theta^T x^{(i)}})
\end{aligned}
\]</span> <span class="math inline">\(\theta\)</span> 满足 <span
class="math display">\[
\frac{\partial }{\partial \theta}\ell(\theta)=0
\]</span> 考虑每一个 <span class="math inline">\(\theta_j,\)</span> 有
<span class="math display">\[
\begin{aligned}
\frac{\partial }{\partial \theta_j}\ell(\theta)
&amp;=\sum_{i=1}^m
\left[-(1-y^{(i)})x_j^{(i)}-\frac{-\mathrm{e}^{-\theta^T
x^{(i)}}}{1+\mathrm{e}^{-\theta^T x^{(i)}}}x_j^{(i)}\right] \\
&amp;=\sum_{i=1}^m
\left[-(1-y^{(i)})+\left(1-\frac{1}{1+\mathrm{e}^{-\theta^T
x^{(i)}}}\right) \right]x_j^{(i)}\\
&amp;=\sum_{i=1}^m(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}
\end{aligned}
\]</span></p>
<blockquote>
<p>如果能注意到 <span class="math inline">\(g(z)\)</span> 满足 <span
class="math inline">\(g&#39;(z)=g(z)(1-g(z))\)</span> 的话, 用链式法则求
<span class="math inline">\(\frac{\partial }{\partial
\theta_j}\ell(\theta)\)</span> 不失为更好的选择.</p>
</blockquote>
<p>这导函数的零点显然是无法用初等函数显式表达出来, 于是可以考虑用<a
href="">最速下降法</a>或<a href="">牛顿法</a>, 迭代过程中更新公式分别为
<span class="math display">\[
\theta_j:=\theta_j+\alpha\sum_{i=1}^m(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}
\]</span></p>
<blockquote>
<p>注意这里是 <span class="math inline">\(+,\)</span>
因为是求最大值的优化问题: <span class="math display">\[
\begin{aligned}
&amp;\max \ell(\theta)\\
\text{s.t. }&amp; \theta \in\mathbb{R}^{n+1}
\end{aligned}
\]</span> 应沿梯度方向迭代而不是负梯度方向.</p>
</blockquote>
<p>将这与线性回归的最速下降法迭代公式作比较,
可以很惊讶地发现两者的形式是完全吻合的.</p>
<p>牛顿法: <span class="math display">\[
\theta:=\theta-\nabla^2\ell(\theta)^{-1}g
\]</span> 其中 <span class="math inline">\(g=\nabla
\ell(\theta),\)</span> 这里采用的是最原始的牛顿法而不是修正牛顿法.</p>
<blockquote>
<p>通过构造的概率密度得到的 <span
class="math inline">\(\ell(\theta)\)</span> 具有非常好的性质, 它在 <span
class="math inline">\(\mathbb{R}^n\)</span> 是凸的,
因此无需再考虑最速下降法或牛顿法会陷入局部最优解的情况了,
因为凸优化问题的局部最优解一定是全局最优解.</p>
</blockquote>
<h2 id="广义线性模型glm">广义线性模型(GLM)</h2>
<p>不管是线性回归还是 logistics 回归, 它们都隶属于概率论中的回归分析,
也就是说 <span class="math inline">\(y\)</span> 总是一个随机变量,
依赖于自变量 <span class="math inline">\(x\)</span> 和参数 <span
class="math inline">\(\theta\)</span> 以及随机误差 <span
class="math inline">\(e,\)</span> 若假定 <span
class="math inline">\(e\sim N(0,\sigma^2),\)</span> 那么 <span
class="math inline">\(y|x;\theta\sim N(\mu,\sigma^2),\)</span> 其中
<span class="math inline">\(\mu=h_{\theta}(x);\)</span> 对于分类问题,
比如二元分类问题, <span class="math inline">\(y|x;\theta\sim
B(1,\phi).\)</span> 在广义线性模型中, <span
class="math inline">\(y\)</span> 的分布不再局限于上面两种形式,
最常见的是指数类型的分布, 这类分布满足概率密度为: <span
class="math display">\[
p(y;\eta)=b(y)\mathrm{e}^{\eta^TT(y)-a(\eta)}
\]</span> 叫做<strong>指数分布族(Exponential family)</strong>, 其中参数
<span class="math inline">\(\eta\)</span> 称为自然参数 (natural
parameter/canonical parameter), <span
class="math inline">\(b(y),T(y)\)</span> 都是 <span
class="math inline">\(y\)</span> 的函数, <span
class="math inline">\(T(y)\)</span> 被称为充分统计量(sufficient
statistic), 对于常见的分布, 一般有 <span
class="math inline">\(T(y)=y\)</span> ; <span
class="math inline">\(a(\eta)\)</span> 是 <span
class="math inline">\(\eta\)</span> 的函数, 它的主要作用是保证 <span
class="math display">\[
\int_{\mathbb{R}^n}p(y;\eta)\mathrm{d} y=1\text{ or }\sum p(y;\eta)=1
\]</span> 使其符合概率密度应满足的特点.</p>
<p>显然, 伯努利分布和正态分布都是指数类型的分布, 下面将说明这一点.</p>
<p><strong>伯努利分布</strong>:</p>
<p>设 <span class="math inline">\(y;\phi\sim
B(1,\phi),y\in\{0,1\},\)</span> 则 <span class="math display">\[
\begin{aligned}
p(y;\phi)
&amp;=\phi^y(1-\phi)^{(1-y)}\\
&amp;=(\exp y\log \phi)\cdot(\exp(1-y)\log(1-\phi))\\
&amp;=\exp \left(y\log\frac{\phi}{1-\phi}+\log(1-\phi)\right)
\end{aligned}
\]</span> 显然就有 <span class="math inline">\(b(y)=1,T(y)=t,\)</span>
且 <span class="math display">\[
\eta=\log\frac{\phi}{1-\phi}\Rightarrow
\phi=\frac{1}{1+\mathrm{e}^{-\eta}}
\]</span> 于是 <span
class="math inline">\(a(\eta)=-\log(1-\phi)=\log\frac{\mathrm{e}^{-\eta}}{1+\mathrm{e}^{-\eta}}=-\log(1+\mathrm{e}^{\eta}).\)</span></p>
<p><strong>正态分布</strong>:</p>
<p>设 <span class="math inline">\(y;\mu,\sigma^2\sim
N(\mu,\sigma^2),\)</span> 则 <span class="math display">\[
\begin{aligned}
p(y;\mu,\sigma^2)
&amp;=\frac{1}{\sqrt{2\pi}\sigma}\mathrm{e}^{-\frac{(y-\mu)^2}{2\sigma^2}}\\
\end{aligned}
\]</span> 需要注意的是, 在回归分析时我们并没有用到 <span
class="math inline">\(\sigma^2,\)</span> 这意味着 <span
class="math inline">\(\sigma^2\)</span> 对于我们构造代价函数 <span
class="math inline">\(h_{\theta}(x)\)</span> 以及最终确定参数 <span
class="math inline">\(\theta\)</span> 并无影响, 因此它可以是任意的,
为了计算简便, 可以令 <span class="math inline">\(\sigma=1,\)</span></p>
<blockquote>
<p>事实上也可以将 <span class="math inline">\(\sigma^2\)</span>
考虑在内, 不过就需要更一般的指数类型的分布的概率密度: <span
class="math display">\[
p(y;\eta)=b(y)\mathrm{e}^{}
\]</span></p>
</blockquote>
<h3 id="三个假设">三个假设</h3>
<p>对于回归问题和分类问题, 我们想根据自变量 <span
class="math inline">\(x\)</span> 预测随机变量 <span
class="math inline">\(y\)</span> 的值, 为了得到广义线性模型,
做出下面的三个假设:</p>
<ul>
<li><span class="math inline">\(y|x;\theta\sim EF(\eta),\)</span> 其中
<span class="math inline">\(EF(\eta)\)</span> 为自然参数为 <span
class="math inline">\(\eta\)</span> 的指数族分布.</li>
<li><span class="math inline">\(\mathbb{E}(y|x)=h(x).\)</span></li>
<li>自然参数 <span class="math inline">\(\eta\)</span> 与自变量 <span
class="math inline">\(x\)</span> 满足线性关系: <span
class="math inline">\(\eta=\theta^Tx.\)</span></li>
</ul>
<p>这三个假设看起来很突兀, 下面一一做解释:</p>
<h4 id="为什么是指数族分布">为什么是指数族分布?</h4>
<p>我们假设 <span class="math inline">\(y|x;\theta\)</span>
服从指数族分布主要有两个原因:</p>
<ol type="1">
<li><p>指数分布具有良好的性质, 若随机变量 <span
class="math inline">\(Y\sim EF(\eta),\)</span> 则 <span
class="math inline">\(Y\)</span> 的期望与方差的形式非常简洁,
我们现在来计算一下.</p>
<p><strong>期望</strong>: 注意到 <span
class="math inline">\(\frac{\partial \log p(y;\eta)}{\partial
\eta}=y-\nabla a(\eta),\)</span> 于是定义随机变量 <span
class="math inline">\(X=Y-\nabla a(\eta),\)</span> 于是 <span
class="math inline">\(\mathbb{E}(X)=\mathbb{E}(Y)-\nabla
a(\eta),\)</span> 且根据<a href="">随机变量函数的期望</a>, 有 <span
class="math display">\[
\begin{aligned}
\mathbb{E}(X)
&amp;=\int (y-\nabla a(\eta))p(y;\eta)\mathrm{d} y\\
&amp;=\int \left(\frac{\partial}{\partial \eta}\log p\right)p\mathrm{d}
y\\
&amp;=\int\frac{1}{p}\frac{\partial p}{\partial \eta}p\mathrm{d} y\\
&amp;=\int \frac{\partial}{\partial \eta}p\mathrm{d} y\\
&amp;=\frac{\partial}{\partial \eta}\int p\mathrm{d} y\\
&amp;=\frac{\partial}{\partial \eta}1=0
\end{aligned}
\]</span> 这就意味着 <span
class="math inline">\(\mathbb{E}(X)=\mathbb{E}(Y)-\nabla
a(\eta)=0,\)</span> 即 <span
class="math inline">\(\boxed{\mathbb{E}(Y)=\nabla a(\eta)}.\)</span></p>
<blockquote>
<p>上面交换积分和求导的次序原则上需要证明一致收敛之类的, 在这里不是重点,
就略去了, 同时用到了概率密度 <span
class="math inline">\(p(y;\eta)\)</span> 的规范性. 若 <span
class="math inline">\(y\in\mathbb{R}^n,\)</span> 则上面的积分都是在整个
<span class="math inline">\(\mathbb{R}^n\)</span> 上进行的.
这里的期望算子 <span class="math inline">\(\mathbb{E}:\mathbb{R}^n \to
\mathbb{R}^n,\)</span> 即对多维随机变量的每一维求期望. 梯度 <span
class="math inline">\(\nabla f(x)\)</span> 按理来说是列向量即 <span
class="math inline">\(\frac{\partial f}{\partial x}=\nabla
f(x)^T,\)</span> 这里为了方便就不区分 <span
class="math inline">\(\frac{\partial f}{\partial x}\)</span> 与 <span
class="math inline">\(\nabla f(x)\)</span> 的区别了.</p>
<p>上面的 "注意到" 好像有点突兀, 也可以从其他角度来求,
但关键还是要想到对 <span class="math inline">\(\eta\)</span>
求导以及交换积分和求导次序, 因为 <span class="math display">\[
\frac{\partial p}{\partial \eta}=p(y-\nabla a(\eta))
\]</span> 这时候出现了 <span class="math inline">\(py,\)</span>
积分后就是期望了, 而且剩下一项刚好是概率密度, 积分后就为 <span
class="math inline">\(1\)</span> 了.</p>
</blockquote>
<p><strong>方差</strong>: <span class="math display">\[
\mathbb{D} (X)=\nabla^2 a(\eta)
\]</span> 即函数 <span class="math inline">\(a(\eta)\)</span>
的黑塞矩阵.</p></li>
<li><p>常见的大多数分布都属于指数分布族.
比如上面提到过的正态分布与伯努利分布, 以及指数分布, 二项分布, 多项分布,
泊松分布, <span class="math inline">\(\Gamma\)</span> 分布, <span
class="math inline">\(\beta\)</span> 分布等等, 都属于指数分布族,
而这些分布又可以刻画大多数问题, 所以假定 <span
class="math inline">\(y\)</span> 服从指数族分布是有一定道理的.</p>
<p><a href="">这里</a>补充了 <span class="math inline">\(\Gamma\)</span>
分布和 <span class="math inline">\(\beta\)</span> 分布,
以及对其他分布属于指数分布族的验证.</p></li>
</ol>
<h4 id="代价函数为什么是期望">代价函数为什么是期望?</h4>
<p>这里确定 <span class="math inline">\(h(x)\)</span>
的过程与回归分析并无二致, 关于连续型随机变量 <span
class="math inline">\(\mathbb{E}(Y|X_1,\cdots,X_n)=f(x_1,\cdots,x_n)\)</span>
的解释, 见<a href="">回归分析</a>, 实际上就是对随机误差期望为 <span
class="math inline">\(0\)</span> 的假定,
也可以借助参数估计的无偏性来理解.</p>
<p>离散型随机变量与连续型随机变量有一点不同</p>
<h4 id="为什么是线性关系">为什么是线性关系?</h4>
<p>线性关系的假定可以看作是一种约定俗成,
这大概是因为因为线性关系具有诸多良好的性质, 就像局部加权回归那样,
如果只关注预测值附近的样本的话, 线性近似带来的误差并不是很大.
更精确的拟合所提高的精度相比计算的代价可能并不那么诱人.</p>
<blockquote>
<p>反正是我瞎说的捏</p>
</blockquote>
<h3
id="借助广义线性模型解决多分类问题-softmax-regression">借助广义线性模型解决多分类问题:
softmax regression</h3>
<p>说了那么多理论和计算, 该看个例子了. 在前面解决了二元分类,
现在我们来看如何用 GLM 解决多分类问题. 多分类问题中, <span
class="math inline">\(\mathcal{Y}=\{1,2,\cdots,k\},\)</span> 表示有
<span class="math inline">\(k\)</span> 类. 在给定 <span
class="math inline">\(x\)</span> 的条件下, 设 <span
class="math inline">\(P(y=i|x;\phi)=\phi_i,\)</span> 其中 <span
class="math inline">\(\phi=(\phi_1,\cdots,\phi_k)\)</span>
的每一维都是概率, 满足 <span class="math inline">\(\sum_{i=1}^k
\phi_i=1.\)</span></p>
<blockquote>
<p>对于命题 <span class="math inline">\(q,\)</span> 记号 <span
class="math inline">\([]:\{\text{true, false}\}\to \{0,1\}\)</span>
表示若 <span class="math inline">\(q\)</span> 为真则 <span
class="math inline">\([q]=1,\)</span> 若 <span
class="math inline">\(p\)</span> 为假则 <span
class="math inline">\([q]=0.\)</span> 比如 <span
class="math inline">\([1=0]=0.\)</span>
(为什么这也要煞有介事地写个映射)</p>
</blockquote>
<p>于是概率密度可以写成: <span class="math display">\[
\begin{aligned}
p(y;\phi)
&amp;=\prod_{i=1}^k\phi_i^{[y=i]}\\
&amp;=\exp \sum_{i=1}^k [y=i]\log \phi_i
\end{aligned}
\]</span> 将其与指数族分布的概率密度对照, 则有 <span
class="math inline">\(\eta=(\log\phi_1,\cdots,\log\phi_k)^T,\)</span>
<span class="math inline">\(T(y)=([y=1],\cdots,[y=k])^T,\)</span> <span
class="math inline">\(b(y)=1,\)</span> 然后就发现出问题了, 此时 <span
class="math inline">\(a(\eta)=0,\)</span> 那代价函数就恒为 <span
class="math inline">\(0\)</span> 了, 显然不对.</p>
<p>问题出在哪里了呢? 因为 <span
class="math inline">\(\phi_1,\cdots,\phi_k\)</span> 满足了 <span
class="math inline">\(\sum_{i=1}^k\phi_i=1,\)</span> 所以这 <span
class="math inline">\(k\)</span> 个参数有一个多余的, 于是用 <span
class="math inline">\(1-\sum_{i=1}^{k-1}\phi_i\)</span> 替换掉 <span
class="math inline">\(\phi_k,\)</span> 那么自然参数就满足 <span
class="math inline">\(\eta\in \mathbb{R}^{k-1}\)</span> 而不是 <span
class="math inline">\(\mathbb{R}^k\)</span> 了,
不过下面的运算过程为了简便仍然用 <span
class="math inline">\(\phi_k\)</span> , 现在置 <span
class="math inline">\(\phi=(\phi_1,\cdots,\phi_{k-1}),\)</span> 则 <span
class="math display">\[
\begin{aligned}
p(y;\phi)
&amp;=\exp \sum_{i=1}^k [y=i]\log \phi_i\\
&amp;=\exp \sum_{i=1}^{k-1}[y=i]\log\phi_i+[y=k]\log \phi_k\\
&amp;=\exp
\sum_{i=1}^{k-1}[y=i]\log\phi_i+\log\phi_k\sum_{\ell=1}^{k}[y=\ell]-\log\phi_k
\sum_{\ell=1}^{k-1}[y=\ell]\\
&amp;=\exp\sum_{i=1}^{k-1}[y=i]\log\frac{\phi_i}{\phi_k}+\log\phi_k
\end{aligned}
\]</span> 于是就有 <span class="math inline">\(\eta
=(\log\phi_1/\phi_k,\cdots,\phi_{k-1}/\phi_k)^T,T(y)=([y=1],\cdots,[y=k-1])^T,b(y)=1,\)</span>
以及 <span class="math display">\[
a(\eta)=-\log\phi_k=-\log\left(1-\sum_{i=j}^{k-1}\phi_j \right)
\]</span> 为了求出 <span class="math inline">\(h(x)=\nabla
a(\eta),\)</span> 先求出 <span class="math inline">\(\eta\)</span> 与
<span class="math inline">\(\phi\)</span> 之间的关系, 这相当于是解方程:
<span class="math display">\[
\begin{cases}
\phi_i=\phi_k\mathrm{e}^{\eta_i},i=1,\cdots,k-1\\
\displaystyle \phi_k=1-\sum_{i=1}^{k-1}\phi_i
\end{cases}
\]</span> 解出 <span class="math display">\[
\phi_k=\frac{1}{1+\sum_{i=1}^{k-1}\mathrm{e}^{\eta_i}}
\]</span> 于是 <span class="math display">\[
a(\eta)=-\log\phi_k=\log \left(1+\sum_{i=1}^{k-1}e^{\eta_i}\right)
\]</span> 且 <span class="math inline">\(\eta_i=\theta_i^Tx,\)</span>
其中 <span class="math inline">\(\theta_i\in\mathbb{R}^{n+1},\)</span>
于是</p>
<p><span class="math display">\[
h(x)=\nabla a(\eta)=
\begin{bmatrix}
\frac{\mathrm{e}^{\eta_1}}{1+\sum_{i=1}^{k-1}\mathrm{e}^{\eta_i}}\\
\frac{\mathrm{e}^{\eta_2}}{1+\sum_{i=1}^{k-1}\mathrm{e}^{\eta_i}}\\
\vdots\\
\frac{\mathrm{e}^{\eta_{k-1}}}{1+\sum_{i=1}^{k-1}\mathrm{e}^{\eta_{i}}}
\end{bmatrix}=
\begin{bmatrix}
\frac{\mathrm{e}^{\theta_1^Tx}}{1+\sum_{i=1}^{k-1}\mathrm{e}^{\theta_i^Tx}}\\
\frac{\mathrm{e}^{\theta_2^Tx}}{1+\sum_{i=1}^{k-1}\mathrm{e}^{\theta_i^Tx}}\\
\vdots\\
\frac{\mathrm{e}^{\theta_{k-1}^Tx}}{1+\sum_{i=1}^{k-1}\mathrm{e}^{\theta_i^Tx}}
\end{bmatrix}
\]</span></p>
<p>这是一个 <span class="math inline">\(k-1\)</span> 维向量, 其中第
<span class="math inline">\(i\)</span> 维是参数 <span
class="math inline">\(P(y=i|x;\phi)=\phi_i\)</span> 的预测值,
利用所有维度可以求出 <span
class="math inline">\(P(y=k|x;\phi)=\phi_k\)</span> 的预测值.
如果想要求出最佳参数, 采用 MLE 并利用梯度法和牛顿法进行求解即可,
似然函数为 <span
class="math inline">\(\prod_{i=1}^{k}P(y=i|x;\phi).\)</span></p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Baoduo Xu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa-thin fa-atom-simple"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Baoduo Xu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">165k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">2:30</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    window.MathJax = {
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '5tA44WzshqSYTe1o3UZ69rbG-gzGzoHsz',
      appKey     : 'mKQ1yQvoXZgY9Fhki3p08I8o',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
