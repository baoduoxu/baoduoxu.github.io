<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/infinity-solid.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/infinity-solid.svg">
  <link rel="mask-icon" href="/images/infinity-solid.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|JetBrains Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="">


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"falt"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="XBD">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="XBD">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Baoduo Xu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>XBD</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XBD</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Everything will end up being TRIVIAL.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        
      
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/math/graph/graph-matching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/math/graph/graph-matching/" class="post-title-link" itemprop="url">图匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-15 11:43:59" itemprop="dateCreated datePublished" datetime="2023-08-15T11:43:59+08:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-16 23:35:59" itemprop="dateModified" datetime="2023-08-16T23:35:59+08:00">2023-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/08/15/math/graph/graph-matching/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/15/math/graph/graph-matching/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<h1 id="二分图最大匹配">二分图最大匹配</h1>
<h2 id="匈牙利算法">匈牙利算法</h2>
<p>匈牙利算法用来求解二分图的最大匹配.</p>
<p>对于一个匹配为 <span class="math inline">\(M\)</span> 的二分图 <span
class="math inline">\(G=(V,E)\)</span>, 顶点集被划分为 <span
class="math inline">\(V_1,V_2\)</span>, 若 <span
class="math inline">\(v\in V\)</span> 满足某个以 <span
class="math inline">\(v\)</span> 为端点的边在 <span
class="math inline">\(M\)</span> 中, 则称 <span
class="math inline">\(v\)</span> 被匹配, 否则称其未被匹配; 若 <span
class="math inline">\(e\in M\)</span> 则称边 <span
class="math inline">\(e\)</span> 为匹配边, 否则称为未匹配边.
定义交替路如下:</p>
<p><strong>定义1 (交替路)</strong> 交替路是一段 path <span
class="math inline">\(v_1,\cdots,v_k\)</span>, 满足 <span
class="math inline">\(v_1\)</span>
未被匹配且路径上的边是未匹配边和匹配边交错的, 即 <span
class="math inline">\((v_{2i-1},v_{2i})\not\in M,(v_{2i},v_{2i+1})\in
M\)</span>. <span class="math inline">\(\square\)</span></p>
<p>在交替路的基础上给出增广路的定义:</p>
<p><strong>定义2 (增广路)</strong> 增广路是一条交替路,
满足其终点未被匹配. <span class="math inline">\(\square\)</span></p>
<p>显然增广路中, 未匹配边比匹配边多一条,
于是可以<strong>将匹配边变成未匹配边,
而未匹配边变成匹配边</strong>(即匹配边和未匹配边进行对调),
这不会违反匹配的要求, 于是得到新的匹配 <span
class="math inline">\(M&#39;\)</span>, 且满足 <span
class="math inline">\(|M&#39;|=|M|+1\)</span>,
这样的一次操作使匹配的条数增加了 <span class="math inline">\(1\)</span>.
于是自然就有下面的思路:</p>
<p>通过搜索不断地发现增广路, 每次找到一条增广路就做如上述的操作,
直到找不到增广路为止.</p>
<blockquote>
<p>每个未被匹配的点只需要枚举一次.</p>
</blockquote>
<h3 id="dfs">DFS</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3386</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">500</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn2=<span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">    _edge(<span class="type">int</span> _from, <span class="type">int</span> _to):<span class="built_in">from</span>(_from),<span class="built_in">to</span>(_to)&#123;&#125;</span><br><span class="line">&#125;Edge; <span class="comment">// 边结构体, 存起点和终点</span></span><br><span class="line">vector&lt;Edge&gt;edge; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">2</span>*maxn+<span class="number">5</span>]; <span class="comment">// g[i]为从顶点i出发的边的编号</span></span><br><span class="line"><span class="type">int</span> mate[<span class="number">2</span>*maxn+<span class="number">5</span>]; <span class="comment">// 存每个点的配偶, 初始化为-1, 同时可以判断是否被匹配了</span></span><br><span class="line"><span class="type">int</span> check[<span class="number">2</span>*maxn+<span class="number">5</span>]; <span class="comment">// 记录点是否在交替路中, 防止重复访问</span></span><br><span class="line"><span class="type">int</span> n,m,e;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123; <span class="comment">// 以s为起点, 返回是否能找到增广路 </span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=g[s].<span class="built_in">begin</span>();it!=g[s].<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">        <span class="type">int</span> v=edge[*it].to;</span><br><span class="line">        <span class="keyword">if</span>(!check[v])&#123;</span><br><span class="line">            check[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mate[v]==<span class="number">-1</span>||<span class="built_in">dfs</span>(mate[v]))&#123;</span><br><span class="line">                mate[v]=s;</span><br><span class="line">                mate[s]=v;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">matching</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mate,<span class="number">-1</span>,<span class="built_in">sizeof</span>(mate));</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mate[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="built_in">sizeof</span>(check));</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i))ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> isv[<span class="number">2</span>*maxn+<span class="number">5</span>][<span class="number">2</span>*maxn+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;e;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(!isv[a][b+n])&#123;</span><br><span class="line">            edge.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(a,b+n));</span><br><span class="line">            g[a].<span class="built_in">push_back</span>(cnt++);</span><br><span class="line">            isv[a][b+n]=isv[b+n][a]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">matching</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bfs">BFS</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3386</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">500</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn2=<span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">    _edge(<span class="type">int</span> _from, <span class="type">int</span> _to):<span class="built_in">from</span>(_from),<span class="built_in">to</span>(_to)&#123;&#125;</span><br><span class="line">&#125;Edge; <span class="comment">// 边结构体, 存起点和终点</span></span><br><span class="line">vector&lt;Edge&gt;edge; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">2</span>*maxn+<span class="number">5</span>]; <span class="comment">// g[i]为从顶点i出发的边的编号</span></span><br><span class="line"><span class="type">int</span> mate[<span class="number">2</span>*maxn+<span class="number">5</span>]; <span class="comment">// 存每个点的配偶, 初始化为-1, 同时可以判断是否被匹配了</span></span><br><span class="line"><span class="type">int</span> pre[<span class="number">2</span>*maxn+<span class="number">5</span>]; <span class="comment">// 存路径, 起点的值为-1, prev[v]存v的前置结点</span></span><br><span class="line"><span class="type">int</span> check[<span class="number">2</span>*maxn+<span class="number">5</span>]; <span class="comment">// 记录点是否在交替路中, 值为当前所在交替路的起点, 防止重复入队</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">matching</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(mate,<span class="number">-1</span>,<span class="built_in">sizeof</span>(mate));</span><br><span class="line">    <span class="built_in">memset</span>(check,<span class="number">-1</span>,<span class="built_in">sizeof</span>(check));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(mate[i]==<span class="number">-1</span>)&#123; <span class="comment">// 找到未被匹配的点, 以该点为起点搜索增广路</span></span><br><span class="line">            <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) Q.<span class="built_in">pop</span>(); <span class="comment">// 每一轮搜索都需要空队列</span></span><br><span class="line">            <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">            Q.<span class="built_in">push</span>(i);</span><br><span class="line">            pre[i]=<span class="number">-1</span>; <span class="comment">// 记录起点</span></span><br><span class="line">            <span class="type">int</span> flag=<span class="number">0</span>; <span class="comment">// 用于判断增广路是否找到了</span></span><br><span class="line">            <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()&amp;&amp;!flag) <span class="comment">// 广搜, 结束条件为队列为空或者找到增广路</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v=Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=g[v].<span class="built_in">begin</span>();it!=g[v].<span class="built_in">end</span>()&amp;&amp;!flag;++it)&#123; <span class="comment">// 满足交错路条件的临界点加入队列</span></span><br><span class="line">                    <span class="type">int</span> u=edge[*it].to; <span class="comment">// u为v的邻接点</span></span><br><span class="line">                    <span class="keyword">if</span>(check[u]!=i)&#123; <span class="comment">// 如果起点不是当前的起点i</span></span><br><span class="line">                        check[u]=i;</span><br><span class="line">                        Q.<span class="built_in">push</span>(mate[u]); <span class="comment">// u的配偶入队, 这里为什么不需要邻接点u入队呢?</span></span><br><span class="line">                        <span class="keyword">if</span>(mate[u]&gt;=<span class="number">0</span>)&#123; <span class="comment">// 如果有配偶, 表明仍然满足交替路的条件, 则记录路径</span></span><br><span class="line">                            pre[u]=v; <span class="comment">// 记录前置结点</span></span><br><span class="line">                            pre[mate[u]]=u;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123; <span class="comment">// 没有配偶, 表明找到了一条增广路, 进行匹配边和非匹配边的转换</span></span><br><span class="line">                            pre[u]=v; <span class="comment">// 记录前置结点</span></span><br><span class="line">                            flag=<span class="number">1</span>;</span><br><span class="line">                            <span class="type">int</span> x=u;</span><br><span class="line">                            <span class="keyword">while</span>(x!=<span class="number">-1</span>)&#123;</span><br><span class="line">                                <span class="type">int</span> y=pre[x];</span><br><span class="line">                                mate[x]=y;</span><br><span class="line">                                mate[y]=x;</span><br><span class="line">                                x=pre[y];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mate[i]!=<span class="number">-1</span>) ans++; <span class="comment">// 如果经过上述搜索, 起点成功有了配偶, 则匹配数目加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> isv[<span class="number">2</span>*maxn+<span class="number">5</span>][<span class="number">2</span>*maxn+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,e;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;e;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(!isv[a][b+n])&#123;</span><br><span class="line">            edge.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(a,b+n));</span><br><span class="line">            g[a].<span class="built_in">push_back</span>(cnt++);</span><br><span class="line">            isv[a][b+n]=isv[b+n][a]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">matching</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用BFS实现时, 需要注意在将点待搜索点放入队列时, 需要放的点是当前点
<span class="math inline">\(u\)</span> 的邻接点 <span
class="math inline">\(v\)</span> 的配偶, 这样相当于一次搜索跳了两步,
包括非匹配边 <span class="math inline">\((u,v)\)</span> 和匹配边 <span
class="math inline">\((v,\mathrm{mate}(v))\)</span>,
效率比深度一次只增加一层要高一些并且不用额外判断是否满足交替路的条件.</p>
<p>和网络流的FF算法和EK算法一样, 使用 BFS 的匈牙利算法要比使用 DFS
的效率高一些(稀疏图尤甚), 虽然时间复杂度都为 <span
class="math inline">\(O(|V||E|)\)</span>. (枚举 <span
class="math inline">\(n=O(|V|)\)</span> 个点, 每个点找增广路需要 <span
class="math inline">\(O(|E|)\)</span> 的时间.)</p>
<h2 id="转化为网络流">转化为网络流</h2>
<h1 id="一般图最大匹配">一般图最大匹配</h1>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/14/CO/network-flow1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/14/CO/network-flow1/" class="post-title-link" itemprop="url">网络流(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-14 17:40:56" itemprop="dateCreated datePublished" datetime="2023-08-14T17:40:56+08:00">2023-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-16 23:36:25" itemprop="dateModified" datetime="2023-08-16T23:36:25+08:00">2023-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">图论</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/08/14/CO/network-flow1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/14/CO/network-flow1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<h1 id="基本概念">基本概念</h1>
<p>已知有向图 <span class="math inline">\(G=(V,E),\)</span> 映射 <span
class="math inline">\(c:E\to \mathbb{R}_{\ge 0}\)</span> 称为 <span
class="math inline">\(G\)</span> 中每条边的<strong>容量</strong>,
是一个非负实数, 记作 <span class="math inline">\(c(e),e\in E\)</span>
或者 <span class="math inline">\(c(u,v),(u,v)\in E,u,v\in V.\)</span> 在
<span class="math inline">\(G\)</span> 中有两个特殊顶点 <span
class="math inline">\(s,t(s\ne t),\)</span> 分别称作源点和汇点,
这样可以用一个五元组 <span class="math inline">\((V,E,c,s,t)\)</span>
表示一个容量网络 <span class="math inline">\(N\)</span>. 定义每条边
<span class="math inline">\(e\)</span> 的可行流为 <span
class="math inline">\(f(e),\)</span> 映射 <span
class="math inline">\(f:E\to \mathbb{R}_{\ge 0},\)</span> 表示大小为有
<span class="math inline">\(f(e)\)</span> 的<strong>流量</strong>流经边
<span class="math inline">\(e,\)</span> <span
class="math inline">\(f\)</span> 需满足两个要求:</p>
<p>1: 每条边的流量不能超过该边的容量, 即 <span
class="math inline">\(\forall e\in E,f(e)\le c(e).\)</span></p>
<p>2: 对于所有的非源点和汇点的点,
流入每个点的流量之和等于流出每个点的流量之和, 即 <span
class="math inline">\(\forall v\in V-\{s,t\},\)</span> 有 <span
class="math display">\[
\sum_{(u,v)\in E}f(u,v)=\sum_{(v,u)\in E}f(v,u)
\]</span></p>
<p>这很像基尔霍夫电流定律, 即流入每个结点的电流等于流出每个结点的电流.
为了方便, 用 <span
class="math inline">\(\mathrm{in}(v),\mathrm{out}(v)\)</span>
分别表示流入 <span class="math inline">\(v\)</span> 和流出 <span
class="math inline">\(v\)</span> 的流量, 在定义了广义结点后, <span
class="math inline">\(\mathrm{in}(),\mathrm{out}()\)</span>
的含义同样适用.</p>
<p>在上面两个要求的定义之下, 可以定义<strong>整张网络的流量</strong>
<span class="math inline">\(\mathcal{F}(f)\)</span> 为原点 <span
class="math inline">\(s\)</span> 的<strong>净流出量</strong>, 或者汇点
<span class="math inline">\(t\)</span> 的<strong>净流入量</strong>, 即
<span class="math display">\[
\mathcal{F}(f)=\mathrm{out}(s)-\mathrm{in}(s)=\mathrm{in}(v)-\mathrm{out}(v)
\]</span> 最关注的问题是最大流问题,
也就是求出一张容量网络的最大流量.</p>
<p>如果对于结点 <span class="math inline">\(u,v\)</span> 同时有 <span
class="math inline">\((u,v)\in E\land (v,u)\in E\)</span> ,
可以定义广义节点 <span class="math inline">\(v&#39;=\{u,v\},\)</span>
或者在 <span class="math inline">\(u,v\)</span> 之间插入一个节点 <span
class="math inline">\(k,\)</span> 并使 <span
class="math inline">\(c(v,k)=c(k,u)=c(v,u)\)</span> 或者 <span
class="math inline">\(c(u,k)=c(k,v)=c(u,v).\)</span>
在后面就默认两个结点之间有且仅有一条边.</p>
<p>容量网络中另一个有用的概念是<strong>割集</strong>: 对于 <span
class="math inline">\(N=(V,E,c,s,t),\)</span> 若 <span
class="math inline">\(A\subset V\)</span> 满足 <span
class="math inline">\(s\in A\land t\in \bar{A},\)</span> 则称 <span
class="math inline">\((A\times \bar{A})\cap E\)</span> 为 <span
class="math inline">\(N\)</span> 的一个割集, 记作 <span
class="math inline">\((A,\bar{A})\)</span> (这只是一种形式上的记法).
割集是一些边的集合, 这些边的流量之和 <span
class="math inline">\(\sum_{e\in (A,\bar{A})}c(e)\)</span>
称为割集的<strong>容量</strong>, 记作 <span
class="math inline">\(C(A,\bar{A}).\)</span> 割集就是把 <span
class="math inline">\(V\)</span> 分成两部分后,
端点分别在两部分的那部分边的集合, 和二分图很是相似.</p>
<p>若将 <span class="math inline">\(A,\bar{A}\)</span> 均看作广义节点,
那么整张网络中只剩下这两个结点, 此时显然有 <span
class="math inline">\(\mathcal{F}(f)=\mathrm{out}(A)-\mathrm{in}(A)=\mathrm{in}(\bar{A})-\mathrm{out}(\bar{A}),\)</span>
以及 <span class="math inline">\(\mathrm{out}(A)=
\mathrm{in}(\bar{A}),\mathrm{out}(\bar{A})= \mathrm{in}(A).\)</span></p>
<p>最关注的问题是最小割问题,
也就是求出一张容量网络的所有割集中容量最小的那个.</p>
<p>下面通过线性规划理论论述最大流与最小割的关系.</p>
<p>最大流与最小割都可以写成线性规划问题的形式.</p>
<p>最大流: <span class="math display">\[
\begin{aligned}
&amp;\max \sum_{(s,u)\in E}f(s,u)-\sum_{(u,s)\in E}f(u,s)\\
\text{s.t.}&amp;\forall e\in E,0\le f(e)\le c(e)\\
&amp;\forall v\in V-\{s,t\},\sum_{(u,v)\in E}f(u,v)=\sum_{(v,u)\in
E}f(v,u)
\end{aligned}
\]</span></p>
<p>最小割: <span class="math display">\[
\begin{aligned}
&amp;\min \sum_{e\in (A\times \bar{A})\cap E}c(e)\\
\text{s.t.}&amp; A\subset V\\
&amp; s\in A,t\in \bar{A}
\end{aligned}
\]</span></p>
<p>最大流问题和最小割问题实际上互为对偶问题, 下面证明这一结论.</p>
<p>考虑用式 <span
class="math inline">\(\mathcal{F}(f)=\mathrm{out}(A)-\mathrm{in}(A),\)</span>
则最大流问题是如下的线性规划问题 <span class="math display">\[
\begin{aligned}
&amp;\max \sum_{(s,u)\in (A\times \bar{A})\cap E}f(s,u)-\sum_{(u,s)\in
(\bar{A}\times A)\cap E}f(u,s)\\
\text{s.t.}&amp;\forall e\in E,0\le f(e)\le c(e)\\
&amp;\forall v\in V-\{s,t\},\sum_{(u,v)\in E}f(u,v)=\sum_{(v,u)\in
E}f(v,u)\\
&amp;A\subset V\\
&amp; s\in A,t\in \bar{A}
\end{aligned}
\]</span> 一共 <span class="math inline">\(m+n-2\)</span>
个约束条件(<span class="math inline">\(m\)</span> 个容量限制, <span
class="math inline">\(n-2\)</span> 个平衡条件) , <span
class="math inline">\(m\)</span> 个变量 <span
class="math inline">\(f(e),e\in E\)</span> , 则对偶问题有 <span
class="math inline">\(m+n-2\)</span> 个变量, <span
class="math inline">\(m\)</span> 个约束条件, 且变量可以写为 <span
class="math inline">\(g(e),e\in E,\)</span> 与 <span
class="math inline">\(m\)</span> 个不等式约束条件进行对应; <span
class="math inline">\(g_1,\cdots,g_{n-2},\)</span> 与 <span
class="math inline">\(n-2\)</span> 个等式约束条件进行对应,
于是对偶问题为 <span class="math display">\[
\begin{aligned}&amp;\min \sum_{e\in E} g(e)c(e)\\\text{s.t.}&amp;
g(e)\ge 0 \\&amp;\forall e\in (A\times \bar{A})\cap E,g(e)\ge
1\\&amp;\forall e\in (\bar{A}\times A)\cap E,g(e)\ge -1\\&amp;A\subset
V\\&amp; s\in A,t\in \bar{A}\end{aligned}
\]</span> 其中 <span class="math inline">\(g_1,\cdots,g_{n-2}\)</span>
是自由变量. 由于 <span class="math inline">\(\forall e,g(e)\ge
0,\)</span> 因此每个 <span class="math inline">\(g(e)\)</span>
都取最小值时 <span class="math inline">\(\sum_{e\in E} g(e)c(e)\)</span>
取得最小值, 此时 <span class="math display">\[
\sum_{e\in E} g(e)c(e)=\sum_{e\in (A\times \bar{A})\cap E}c(e)
\]</span> 因此上述优化问题就可以改写为 <span class="math display">\[
\begin{aligned}
&amp;\min \sum_{e\in (A\times \bar{A})\cap E}c(e)\\
\text{s.t.}&amp; A\subset V\\
&amp; s\in A,t\in \bar{A}
\end{aligned}
\]</span> 也就是最小割问题.
这就证得了最大流与最小割问题互为对偶问题.</p>
<p>下面介绍常见的算法.</p>
<h1 id="ff算法">FF算法</h1>
<p>首先是Ford-Fulkerson算法. 最简单的想法是,
从源点开始搜索到汇点的可行路径,
该条路径上的最小容量为该条路径上的可行流, 不断重复该过程,
直到没有可行路径为止, 所有可行流的流量.</p>
<p>给出一些定义:</p>
<ul>
<li>增广路: 考虑从 <span class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的一条路径, 在该条路径中,
如果所有前向边非饱和, 所有后向边非零流, 则称这样的一条路径为增广路.</li>
</ul>
<p>FF算法就是通过DFS不断搜索增广路的过程, 需要注意的是,
每找到一条增广路且有 <span class="math inline">\(f(u,v)\)</span>
的流流过边 <span class="math inline">\((u,v)\)</span> 时, 需要再使 <span
class="math inline">\(-f(u,v)\)</span> 的流流过 <span
class="math inline">\((u,v)\)</span>, 即建立反向边 <span
class="math inline">\((v,u)\)</span>, 并使得 <span
class="math inline">\(f(u,v)\)</span> 的流流过 <span
class="math inline">\((v,u)\)</span>,
这个过程实际上相当于一个撤销返反悔的过程,
即在刚开始搜索得到的可行流可能并不是最优的,
它们中有的边可能并不需要经过.</p>
<p>下面给出FF算法的证明, 即下面的定理:</p>
<p>可行流 <span class="math inline">\(f\)</span> 是最大流的充要条件是
<span class="math inline">\(N\)</span> 中不存在增广路.</p>
<p><strong><em>PROOF</em></strong> 必要性: 如果 <span
class="math inline">\(f\)</span> 是最大流, 且仍然存在增广路,
设增广路可流的剩余流量为 <span
class="math inline">\(\delta&gt;0\)</span>,
显然可以继续从增广路增加流量, 增加 <span
class="math inline">\(\delta\)</span> 后的流 <span
class="math inline">\(f&#39;\)</span> 显然是最大流, 且此时不存在增广路,
这就证得了必要性.</p>
<p>充分性. 假设 <span class="math inline">\(N\)</span>
中不存在关于可行流 <span class="math inline">\(f\)</span> 的 <span
class="math inline">\(s-t\)</span> 增广路, 置集合 <span
class="math inline">\(A=\{j\in V:存在关于f的s-j增广路\}\)</span>, 同时令
<span class="math inline">\(s\in A\)</span>, 显然由条件可得 <span
class="math inline">\(t\not\in A\)</span>. 对任意 <span
class="math inline">\((i,j)\in (A,\bar{A})\)</span>, 必定有 <span
class="math inline">\(f(i,j)=c(i,j)\)</span>,
即割集中的每条边都是饱和的, 否则, 假设存在 <span
class="math inline">\((i,j)\)</span> 使得 <span
class="math inline">\(f(i,j)\le c(i,j)\)</span>, 由于 <span
class="math inline">\(i\in A\)</span>, 则 <span
class="math inline">\(s-i\)</span> 增广路可以延伸到 <span
class="math inline">\(j\)</span>, 这就意味着 <span
class="math inline">\(j\in A\)</span>, 这与 <span
class="math inline">\(j\in \bar A\)</span> 显然矛盾, 于是割集 <span
class="math inline">\((A,\bar{A})\)</span> 的每条边都是饱和的.
同理可以证明所有的 <span class="math inline">\((j,i)\in
(\bar{A},A)\)</span> 都是零流的, 即若存在非零流的 <span
class="math inline">\((j,i)\)</span>, 仍然可以得到 <span
class="math inline">\(j\in\bar{A}\)</span>, 矛盾! 于是 <span
class="math display">\[
v(f)=\sum_{(i,j)\in (A\times \bar{A})\cap E}f(s,u)-\sum_{(j,i)\in
(\bar{A}\times A)\cap E}f(u,s)=\sum_{(i,j)\in
(A,\bar{A})}c(i,j)=c(A,\bar{A})
\]</span> 这实际上就是最大流.这同时也再一次证明了最大流等于最小割.</p>
<p>FF的时间复杂度: 记 <span class="math inline">\(C=\sum_{(s,j)\in
E}c(s,j)\)</span>, 且容量均为整数,
则每次搜索后至少会当前可行流的流量至少增加 <span
class="math inline">\(1\)</span>, 且每次至多遍历所有的边,
于是时间复杂度为 <span class="math inline">\(O(C|E|)\)</span>,
与流量的大小成正比.</p>
<p>FF算法的过程, 在基础的DFS基础上, 遍历的时候要给点做一些标记,
包括点是否被访问过的标记, 到当前点 <span
class="math inline">\(j\)</span> 的前一个顶点 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\((i,j)\)</span> 为前向边还是反向边, 以及到当前点时
<span class="math inline">\(j\)</span>
的路径上的所有正向边的残存容量与反向边的容量的最小值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3376</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">205</span>][<span class="number">205</span>]; <span class="comment">//采用邻接矩阵</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> inf=<span class="number">0x7777777</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t,ans=<span class="number">0</span>,isv[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> flow)</span></span>&#123; <span class="comment">//_min为这条增广路上的最小容量</span></span><br><span class="line">    <span class="keyword">if</span>(v==t)&#123;</span><br><span class="line">        <span class="keyword">return</span> flow; <span class="comment">//该增广路的流量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[v][i]&gt;<span class="number">0</span>&amp;&amp;isv[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            isv[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> c=<span class="built_in">dfs</span>(i,<span class="built_in">min</span>(flow,a[v][i]));</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="number">-1</span>)&#123;</span><br><span class="line">                a[v][i]-=c;</span><br><span class="line">                a[i][v]=c;<span class="comment">//建反边</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">dfs</span>(s,inf))&amp;&amp;c!=<span class="number">-1</span>)&#123;</span><br><span class="line">        ans+=c;</span><br><span class="line">        <span class="built_in">memset</span>(isv,<span class="number">0</span>,<span class="built_in">sizeof</span>(isv));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cin&gt;&gt;a[x][y]; <span class="comment">//容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FF</span>();</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ek算法">EK算法</h1>
<p>EK算法并没有在FF算法上做什么改进, 只是换了搜索方式,
即使用BFS而不是DFS. 但是这会使得EK算法的性能好于FF算法,
因为BFS能保证每次找到的增广路是最短的(假设边权为 <span
class="math inline">\(1\)</span>),
而DFS为了找到容量最大的增广路可能会绕远路.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a[<span class="number">205</span>][<span class="number">205</span>]; <span class="comment">//采用邻接矩阵</span></span><br><span class="line">ll <span class="type">const</span> inf=<span class="number">0xffffffffff</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">ll flow[<span class="number">205</span>];<span class="comment">//流向每个结点的流量，其中流向源点的流量可以认为是inf</span></span><br><span class="line">ll last[<span class="number">205</span>];<span class="comment">//每个结点的前置结点，默认为-1，即如果为-1表示</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(last,<span class="number">-1</span>,<span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">    flow[s]=inf;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(u==t)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[u][i]&gt;<span class="number">0</span>&amp;&amp;last[i]==<span class="number">-1</span>&amp;&amp;i!=s)&#123;</span><br><span class="line">                last[i]=u;</span><br><span class="line">                flow[i]=<span class="built_in">min</span>(flow[u],a[u][i]);<span class="comment">//流向结点i的流量是流向u的流量与边(u,i)的当前容量的较小值</span></span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">()</span></span>&#123; <span class="comment">//要不停地进行bfs，直到无法搜索到汇点t</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()!=<span class="number">-1</span>)&#123;<span class="comment">///每次搜索过后都要更新整张网络</span></span><br><span class="line">        ans+=flow[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t;i!=s&amp;&amp;i!=<span class="number">-1</span>;i=last[i])&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            flow[last[i]]=flow[i];</span><br><span class="line">            a[last[i]][i]-=flow[i];</span><br><span class="line">            a[i][last[i]]+=flow[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        ll w;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">        a[x][y]+=w; <span class="comment">//容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dinic算法">Dinic算法</h1>
<p>FF算法每次只能找到一条增广路, 同时每次寻找的时候都需要重新进行标号,
然后在寻找新的增广路时, 原来顶点的标号可能不变, 这样就造成了重复标号,
Dinic算法就是这样的思想, 借助已经做过的标记,
防止做重复性工作来提高效率.</p>
<p>现在定义关于容量网络 <span class="math inline">\(N\)</span>
上的可行流 <span class="math inline">\(f\)</span> 的辅助网络 <span
class="math inline">\(N(f)=\langle V,E_f,c_a,s,t
\mathbb{R}angle\)</span>: <span class="math inline">\(E_f=E^+_f\cup
E_f^-\)</span>, 其中 <span class="math inline">\(E^+_f=\{(i,j)\in
E:f(i,j)&lt;c(i,j)\},E_f^-=\{(j,i)\in E:f(i,j)&gt;0\}\)</span>, 即 <span
class="math inline">\(E_f^+\)</span> 并表示不饱和的正向边, <span
class="math inline">\(E_f^-\)</span> 表示流量大于零的反向边. <span
class="math inline">\(c_a:E_f\to\mathbb{R}_{+}\)</span> 满足 <span
class="math display">\[
c_a(i,j)=
\begin{cases}
c(i,j)-f(i,j),&amp;(i,j)\in E_f^+\\
f(j,i),&amp;(i,j)\in E_f^-
\end{cases}
\]</span> <span class="math inline">\(c_a\)</span> 称为辅助容量, 显然,
<span class="math inline">\(N(f)\)</span> 也是一个容量网络, <span
class="math inline">\(c_a\)</span> 是它的容量, 不难发现, <span
class="math inline">\(N(f)\)</span> 中的<span
class="math inline">\(s-t\)</span> 有向路径均为 <span
class="math inline">\(N\)</span> 中的 <span
class="math inline">\(s-t\)</span> 增广路.</p>
<p>首先想关注的问题是,辅助容量网络 <span
class="math inline">\(N(f)\)</span> 的最大流和原容量网络 <span
class="math inline">\(N\)</span> 的最大流有什么关系呢?
这是下面的定理:</p>
<p>设 <span class="math inline">\(N\)</span> 的最大流为 <span
class="math inline">\(v_N\)</span>, 则 <span
class="math inline">\(f\)</span> 是它的一可行流, 则 <span
class="math inline">\(N(f)\)</span>的最大流为 <span
class="math inline">\(v_N-v(f)\)</span>.</p>
<p><strong><em>PROOF</em></strong> 设 <span
class="math inline">\(N\)</span> 的一个割集为 <span
class="math inline">\((A,\bar{A})\)</span>, 显然它也是 <span
class="math inline">\(N(f)\)</span> 的一个割集, 记作 <span
class="math inline">\((A,\bar{A})_f\)</span>, <span
class="math inline">\((A,\bar{A})_f\)</span> 包括 <span
class="math inline">\((A,\bar{A})\)</span> 的非饱和正向边和非零流反向边,
设这两者的集合分别为 <span class="math inline">\(E_1,E_2\)</span>,
那么可以得到 <span class="math display">\[
\begin{aligned}
c_a((A,\bar{A})_f)
&amp;=\sum_{(i,j)\in E_1}(c(i,j)-f(i,j))+\sum_{(i,j)\in E_2}f(j,i)\\
&amp;=\sum_{(i,j)\in (A,\bar{A})}(c(i,j)-f(i,j))+\sum_{(j,i)\in
(\bar{A},A)}f(j,i)\\
&amp;=\sum_{e\in (A,\bar{A})}c(e)-\left(\sum_{(i,j)\in
(A,\bar{A})}f(i,j)-\sum_{(j,i)\in (\bar{A},A)}f(j,i) \right)\\
&amp;=c(A,\bar{A})-v(f)
\end{aligned}
\]</span> 且 <span class="math inline">\(c(A,\bar{A})=v_N\)</span>,
这就证得了 <span
class="math inline">\(c_a((A,\bar{A})_f)=v_N-v(f)\)</span>, 同时 <span
class="math inline">\(c_a((A,\bar{A})_f)\)</span> 也为 <span
class="math inline">\(N(f)\)</span> 的最大流.</p>
<p>设 <span class="math inline">\(f\)</span> 为 <span
class="math inline">\(N\)</span> 上的可行流, <span
class="math inline">\(g\)</span> 为 <span
class="math inline">\(N(f)\)</span> 上的可行流, 定义 <span
class="math inline">\(f&#39;=f+g\)</span> 满足对任意 <span
class="math inline">\((i,j)\in E\)</span> 都有 <span
class="math inline">\(f&#39;(i,j)=f(i,j)+g(i,j)-g(j,i)\)</span>, 那么
<span class="math inline">\(f+g\)</span> 也是 <span
class="math inline">\(N\)</span> 上的可行流, 且满足 <span
class="math inline">\(v(f+g)=v(f)+g(f)\)</span>.</p>
<p>现在在 Dinic 算法中引入分层的思想. 设 <span
class="math inline">\(s\)</span> 的层数为 <span
class="math inline">\(0\)</span>, 顶点 <span
class="math inline">\(u\)</span> 的层数 <span
class="math inline">\(d(u)\)</span> 定义为 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(u\)</span> 的最短路径, 且边权定义为 <span
class="math inline">\(1\)</span>, 这通过一次BFS便可预处理出, 并令 <span
class="math inline">\(d=d(t)\)</span>, 显然要获得最短的可行流,
可行流不可能从高层流向低层, 同时不会经过 <span
class="math inline">\(d(x)&gt;d\)</span> 的点 <span
class="math inline">\(x\)</span>. 现在定义分层辅助网络 <span
class="math inline">\(N_A(f)\)</span> 为删去 <span
class="math inline">\(N(f)\)</span> 中冗余的边和点,
冗余的边和点定义如上, 即高层到低层的边以及层数大于 <span
class="math inline">\(d\)</span> 的点, 用符号表示为 <span
class="math inline">\(N_A(f)=(V_f,E_A(f),c_a,s,t)\)</span>, 且 <span
class="math inline">\(\displaystyle V_f=\bigcup_{0 \le k\le
d}V_{f_k},V_{f_k}=\{i\in V:d(i)=k\},0\le k\le
d-1,V_{f_d}=\{t\}\)</span>, <span class="math inline">\(\displaystyle
E_A(f)=\bigcup_{0\le k\le d-1}E_{f_k},E_{f_k}=\{(i,j)\in E_f:i\in
V_{f_k}\land j\in V_{f_{k+1}}\}\)</span>. 即 <span
class="math inline">\(V_{f_k}\)</span> 表示第 <span
class="math inline">\(k\)</span> 层顶点的集合, <span
class="math inline">\(E_{f_k}\)</span> 表示起点为第 <span
class="math inline">\(k\)</span> 层顶点终点为第 <span
class="math inline">\(k+1\)</span> 层顶点的有向边. 于是 <span
class="math inline">\(N_A(f)\)</span> 实际上是一个有向无环图,
且只有一个源点和汇点.</p>
<p>如果 <span class="math inline">\(N\)</span> 中不存在关于 <span
class="math inline">\(f\)</span> 的且不含反向边的增广路, 那么称 <span
class="math inline">\(f\)</span> 为 <span
class="math inline">\(N\)</span> 中的极大流.
显然可行流是最大流的必要条件是可行流为极大流. Dinic算法的关键步骤是求
<span class="math inline">\(N_A(f)\)</span> 的极大流, 即在 <span
class="math inline">\(N_A(f)\)</span> 中找到尽可能多的可行流.</p>
<p>对于每个顶点而言, 能流经该顶点 <span class="math inline">\(i\)</span>
的最大流量显然为终点为该顶点的边的容量和与起点为该顶点边的容量和这两者之间的最小值,
记作 <span class="math inline">\(\ell(i)\)</span>, 规定 <span
class="math inline">\(\ell(s)=\ell(t)=\infty\)</span>.</p>
<p>求 <span class="math inline">\(N_A(f)\)</span>
的极大流的过程也类似于寻找增广路, 但是不像FF算法那样一条一条的找,
而是一次找多条. 在定义过顶点最大流量 <span
class="math inline">\(\ell\)</span> 后, 只需要删去满足 <span
class="math inline">\(\ell(u)=0\)</span> 的顶点及其边, 在剩下的顶点中,
假设 <span class="math inline">\(k=\arg\min_{y\in E_A(f)}
\ell(y)\)</span>, 那么就把流量 <span
class="math inline">\(\ell(k)\)</span> 推送到 <span
class="math inline">\(t\)</span>, 再反向推送到 <span
class="math inline">\(s\)</span>, 接着删去 <span
class="math inline">\(k\)</span> 及其相邻的边, 然后再删去 <span
class="math inline">\(N(f)\)</span> 中已经饱和的边, 得到新的 <span
class="math inline">\(N_A(f)\)</span>, 直到 不存在从 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的路径为止, 此时便得到了 <span
class="math inline">\(N_A(f)\)</span> 的极大流 <span
class="math inline">\(g\)</span>, 接着置 <span
class="math inline">\(f:=f+g\)</span> 即可, 直到 <span
class="math inline">\(N(f)\)</span> 中也不存在从 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的路径, 算法即可停止.</p>
<p>Dinic 算法得到的 <span class="math inline">\(f\)</span> 是最大流,
且复杂度为 <span class="math inline">\(O(|V|^3)\)</span>.</p>
<p><strong><em>PROOF</em></strong> 算法终止时, <span
class="math inline">\(N(f)\)</span> 不存在从 <span
class="math inline">\(s\)</span> 到 <span
class="math inline">\(t\)</span> 的路径, 这意味着 <span
class="math inline">\(N(f)\)</span> 的最大流为零, 于是 <span
class="math inline">\(v_N=v(f)\)</span>, 即 <span
class="math inline">\(f\)</span> 为 <span
class="math inline">\(N\)</span> 的最大流. 注意到每个阶段的 <span
class="math inline">\(N_A(f)\)</span> 中的 <span
class="math inline">\(d(t)\)</span> 都大于前一阶段的 <span
class="math inline">\(d(t)\)</span>, 而整张图中最长路径为 <span
class="math inline">\(|V|\)</span>, 于是至多有 <span
class="math inline">\(|V|\)</span> 个阶段. 在每个阶段中,
需要做的事情包括构造 <span class="math inline">\(N_A(f)\)</span> 和计算
<span class="math inline">\(\ell\)</span>, 这在一次BFS中可以做到,
复杂度为 <span class="math inline">\(O(|E|)\)</span>; 接着需要计算极大流
<span class="math inline">\(g\)</span>, 包括删边和修改容量,
删边的次数显然为 <span class="math inline">\(O(|E|)\)</span> 次,
而对于修改容量, 由于 <span class="math inline">\(N_A(f)\)</span>
为有向无环图, 则推送最小 <span class="math inline">\(\ell(k)\)</span>
时至多推送 <span class="math inline">\(|V|\)</span> 次,
每次推送修改容量至多修改 <span class="math inline">\(|V|\)</span> 次,
于是工作为 <span class="math inline">\(O(|V|^2)\)</span>,
因此每个阶段的复杂度为 <span
class="math inline">\(O(|E|)+O(|E|)+O(|V|^2)=O(|V^2|)\)</span>,
于是最终的复杂度为 <span class="math inline">\(O(|V|^3)\)</span>.</p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/11/seminar/august2023/advanced-informed-search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/11/seminar/august2023/advanced-informed-search/" class="post-title-link" itemprop="url">Advanced Informed Search</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-11 15:07:14" itemprop="dateCreated datePublished" datetime="2023-08-11T15:07:14+08:00">2023-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-14 20:28:52" itemprop="dateModified" datetime="2023-08-14T20:28:52+08:00">2023-08-14</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/08/11/seminar/august2023/advanced-informed-search/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/11/seminar/august2023/advanced-informed-search/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>984</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>当我们想要用搜索解决一个问题时, 通常有下述手段可以使用:</p>
<ol type="1">
<li>Search Information. 主要是 branch 的方式.</li>
<li>Search Strategy. 主要是搜索的方式, 包括 回溯, DFS, BFS, <span
class="math inline">\(\rm A^*, IDA^*,SMA^*\)</span> 等, 具体内容在<a
target="_blank" rel="noopener" href="https://baoduoxu.github.io/2023/07/29/seminar/july2023/search-strategy/">这篇文章</a>中有介绍.</li>
<li>Bound Techniques. 包括 upper bound 和 lower bound,
一般是通过弱化/加强条件,
放缩松弛(线性规划技术)以及启发式等方法来获取原问题解的上下界,
这些解本身可以直接使用, 也可以用作搜索过程中的剪枝.</li>
<li>Decomposition Techniques.</li>
<li>Techniques for deciding which question to branch on.</li>
<li>Techniques for indentifying and solving tractable subproblems at
each node.</li>
<li>Random restart techniques. 当搜索花费了相当长的时间时,
可以随机选择一个问题来 branching 继而重新尝试搜索. 一般没什么用处.</li>
<li>Caching Techniques. 存储一些子问题,
如果在后续的搜索过程中再次遇到这些子问题就直接取其解而不需要再求解.
一般的规则是: 存储经常碰到的子问题; 存储需要耗费了大量搜索代价的子问题;
存储可以被快速检索到的子问题.</li>
</ol>
<p>值的详细介绍的是 1, 3, 4, 5, 6.</p>
<p>下面以 Winner determination problem(WDP) 为例子来进行介绍,
这个问题表述如下:</p>
<p>给定商品集 <span class="math inline">\(M=[m]\)</span> 和 bid 集合
<span class="math inline">\(\mathcal{B}=\{B_1,\cdots,B_n\}\)</span>,
其中第 <span class="math inline">\(j\)</span> 个竞标 bid <span
class="math inline">\(B_j\)</span> 为二元组 <span
class="math inline">\((S_j,p_j)\)</span>, <span
class="math inline">\(S_j\subset M\)</span> 是商品的集合, <span
class="math inline">\(p_j\)</span> 为价格, 表示第 <span
class="math inline">\(j\)</span> 个 bid 出价 <span
class="math inline">\(p_j\)</span> 来拍卖 <span
class="math inline">\(B_j\)</span> 中的所有商品. WDP
要求选择最优的竞标集使得商品拍卖的总价格最大.</p>
<p>这实际上是一个带权独立集的问题, 即将 <span
class="math inline">\(S_j\)</span> 作为无向图 <span
class="math inline">\(G=(V,E)\)</span> 的顶点 <span
class="math inline">\(v_j\)</span>, 则 <span
class="math inline">\(|V|=n\)</span>, 每个顶点有点权 <span
class="math inline">\(p_j\)</span>, 若商品 <span
class="math inline">\(i\)</span> 满足 <span class="math inline">\(i\in
S_j\land i\in S_k\)</span> 则 <span class="math inline">\((v_j,v_k)\in
E\)</span>, 那么 WDP 就是求 <span class="math inline">\(G\)</span>
的最大权独立集.</p>
<h1 id="branch">Branch</h1>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/11/CO/algorithm-complexity-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/11/CO/algorithm-complexity-theory/" class="post-title-link" itemprop="url">算法复杂性理论入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-11 11:30:41" itemprop="dateCreated datePublished" datetime="2023-08-11T11:30:41+08:00">2023-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-15 18:22:37" itemprop="dateModified" datetime="2023-08-15T18:22:37+08:00">2023-08-15</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/08/11/CO/algorithm-complexity-theory/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/11/CO/algorithm-complexity-theory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>171</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>记所有字母的集合为 <span class="math inline">\(\Sigma\)</span>,
若干字母组合成为字符串 <span class="math inline">\(s\)</span>, 记 <span
class="math inline">\(\Sigma^*\)</span> 为所有字符串的集合, <span
class="math inline">\(\emptyset_{s}\)</span> 为空串, 语言 <span
class="math inline">\(L\)</span> 为字符串的集合, <span
class="math inline">\(\emptyset_L\)</span> 为空语言, 且 <span
class="math inline">\(L\subset \Sigma^*\)</span>.</p>
<h1 id="mathsfp-和-mathsfnp"><span
class="math inline">\(\mathsf{P}\)</span> 和 <span
class="math inline">\(\mathsf{NP}\)</span></h1>
<h1 id="图灵机">图灵机</h1>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/06/essay/thought1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/essay/thought1/" class="post-title-link" itemprop="url">一点想法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-06 23:23:18" itemprop="dateCreated datePublished" datetime="2023-08-06T23:23:18+08:00">2023-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-10 12:19:14" itemprop="dateModified" datetime="2023-08-10T12:19:14+08:00">2023-08-10</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/08/06/essay/thought1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/essay/thought1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>37</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<blockquote>
<p>用两句话概括我大学前两年的生活:</p>
<ul>
<li><p>什么都想学, 什么都学不会.</p></li>
<li><p>两手抓, 两手丢.</p></li>
</ul>
</blockquote>
<!-- 今天是2023.8.6, 距离返校还有三四天, 返校后就正式开始大三的生活了.

总结一下大二下的生活.

因为疫情提前回家, 寒假凭空多出来一个月, 所以提前返校了一周来复习期末考试, 可惜的是复习得不怎么样, 数据结构考得很烂, 其他科目也没有到95+, 所以均分仍然没有到自己理想的水平, 还是复习得不够充分, 实力也不行, 不过上了大学以后, 好像就没有哪件事再像高中那样准备得"很充分"了, 不过是面试还是考试竞赛, 总有学不完的东西填不完的坑, 可能这才是常态.

考完概率论, 培养方案就没有(算保研的)数学基础课了(这学期的矩阵分析不算), 自己可能也就没有什么优势了. 说来也奇怪, 都快大三了, 我对自己的定位似乎还是"喜欢数学", 对于真正与计算机相关的课程并不十分感兴趣, 当然也不能这么说， 毕竟写代码搞些小玩意儿还是挺有意思地, 不过相比之下还是数学对我更有吸引力一点, 所以对于这学期的计网/计组/数据库, 我的学习动力好像并没有很强, 再加上我这上课睡觉的毛病, 这三门课无一例外都考得很烂, 这学期的排名肯定会掉一些. 

是摆烂了吗? 应该是, 毕竟我上计网数据库的时候光睡觉, 上计组的时候听不懂就摸鱼, 最后的综合实验也不会做, 只能连抄带编带搜带问 ChatGPT 地搞完了; 好像也不是, 我能想起来导师让我写优化算法地时候我每天都在写代码 debug, 经常在深夜(十二点算深夜吗?)写, 四五月份同时准备数竞/数模/蓝桥杯, 不过还好没有怎么看数模, 不然真的就心力交瘁了(是吗? 蓝桥杯数竞那水题, 认真做也不会怎么耗时间). 

为什么听不懂呢? 现在想来, 可能还是需要预习, 希望下学期对每门课(尤其是OS和KR吧)能做好简单的预习, 上课也不能再摸鱼了, 总要做点有意义的事情的. **不要高估了自己一天能做的事, 也不要低估了自己一年能做的事.** 至于上课睡觉, 仔细考虑原因, 首先是睡眠不足, 其次是内容不感兴趣或者是听不太懂, 所以做自己的事情, 尤其是写代码可以有效防止上课打瞌睡.

睡两年了, 希望最后一年能有改善吧.

看来人的 taste 不是一成不变的, 我记得大一刚开学的时候我对分析还挺感兴趣, 后来就逐渐对数论和组合感兴趣了, 觉得知乎上那些复杂的积分也索然无味了, 现在的想法就是搞组合优化, 但是作为计算机专业的人还是要有工程能力, 否则就是走应用数学的路子了, 所以还是想学一下系统层面的优化. 不过还是有点顾虑, 不知道自己是否有天赋去做这个, 但至少不会在 AI 相关的 CV/NLP/多模态之类的方向之间纠结了, 也不用当炼丹师了(希望如此).

这几天在家十分焦虑, 但是就是学不进去, 自己一个人学习太容易碰壁了, 没有人能沟通交流而要靠自己去想明白一些东西太痛苦了, 还是会经常幻想要是自己智商再高一点就好了. 希望提前返校能改善一下状态, 但是身份证还没到, 也走不了.

开学后还要先准备将近四个周的数模, 实在是太煎熬了, 本来之前对数模还信心满满的, 但是经过两次训练好像感觉也不是那回事, 其他人也很厉害, 自己还是有很多欠缺的知识, 只能在8.17之前再稍微补一下基础了.

在舒适圈待得太久了, 好像跳不出来了. -->
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/06/OR/int-prop/benders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/06/OR/int-prop/benders/" class="post-title-link" itemprop="url">Benders' Algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-06 11:10:53" itemprop="dateCreated datePublished" datetime="2023-08-06T11:10:53+08:00">2023-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-08 16:53:54" itemprop="dateModified" datetime="2023-08-08T16:53:54+08:00">2023-08-08</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/08/06/OR/int-prop/benders/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/06/OR/int-prop/benders/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>938</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>解决混合整数规划问题 <span
class="math inline">\(Z=\max\{cx+hy:Fx+Gy\le d,x\in X\subset
\mathbb{Z}^n_+,y\in\mathbb{R}_+^p\}\)</span>,
可以人为地规定变量优化的顺序, 将其写成类似于 bilevel optimization
的形式: <span class="math display">\[
\begin{aligned}
\max ~&amp;cx+\phi(x)\\
\text{s.t. }&amp;x\in X\\
&amp;\phi(x)=\max\{hy:gy\le d-Fx,y\in\mathbb{R}^p_+\}
\end{aligned}
\]</span> 上面是先把 <span class="math inline">\(x\)</span>
作为参数求解一个线性规划问题, 再求解剩下的子问题.</p>
<blockquote>
<p>如何证明这两种写法的等价性?</p>
<p>感觉好像不太对, 更像是一种启发式规则.</p>
<p>好吧不算很简单，需要好好看一下怎么搞。</p>
</blockquote>
<p>假设 <span class="math inline">\(\phi(x)\)</span> 是有界的, 那么由
Farkas 引理可知 <span class="math inline">\(\phi(x)\)</span> 是 feasible
的 <span class="math inline">\(\iff\)</span> <span
class="math inline">\(v^{(t)}(d-Fx)\ge 0,t=1,\cdots,T\)</span>, 其中
<span class="math inline">\(\{v^{(t)}\}_{t=1}^T\)</span> 是凸集 <span
class="math inline">\(U=\{u\in\mathbb{R}_+^m:uG\ge h\}\)</span>
的极方向(extreme ray).</p>
<p>若求解 <span class="math inline">\(\phi(x)\)</span> 的线性规划是
feasible 的, 那么 <span class="math display">\[
\phi(x)=\min_{1\le s\le S}u^{(s)}(d-Fx)
\]</span> 其中 <span class="math inline">\(\{u^{(s)}\}_{s=1}^S\)</span>
是 <span class="math inline">\(U\)</span> 的极点, 这可以改写为 <span
class="math display">\[
\phi(x)=\max_{\eta\le u^{(s)}(d-Fx)\atop1\le s\le S}\eta
\]</span> 将离散问题转化为了一个连续的线性规划问题, 那么就可以将 <span
class="math inline">\(Z\)</span> 写成 <span class="math display">\[
\begin{aligned}
Z=\max ~&amp;cx+\eta\\
\text{s.t. }&amp;x\in X,\eta\in\mathbb{R}\\
&amp;v^{(t)}(d-Fx)\ge 0,t=1,\cdots,T\\
&amp;u^{(s)}(d-Fx)\ge \eta,s=1,\cdots, S
\end{aligned}
\]</span> 这个问题约束的个数是指数级别的, 解决该问题最好的方法是
branch-and-cut.</p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/05/seminar/august2023/csp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/05/seminar/august2023/csp/" class="post-title-link" itemprop="url">CSP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-05 07:44:56" itemprop="dateCreated datePublished" datetime="2023-08-05T07:44:56+08:00">2023-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-14 20:55:19" itemprop="dateModified" datetime="2023-08-14T20:55:19+08:00">2023-08-14</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/08/05/seminar/august2023/csp/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/05/seminar/august2023/csp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>CSP 是 Constraint Satisfaction Problem 的缩写,
目的是找到符合约束条件的一组解.</p>
<p>相比搜索问题, CSP 的 <strong>状态(state)</strong> 是由变量 <span
class="math inline">\(X_i\)</span> 及其定义域 <span
class="math inline">\(D_i\)</span> 定义的, <strong>目标状态(goal
test)</strong> 是一组约束, 这些约束确定了变量的取值组合.
主要思想通过寻找违反约束的变量或值组合来减少搜索空间的大小,
即做剪枝.</p>
<p>变量分为离散变量和连续变量, 离散变量的取值可以是有限集(比如
boolean)或者无限集(比如整数集或字符串).
通过约束的变量个数对约束进行分类, 包括 unary, binary以及 higher-order.
下面会更多地介绍 binary-CSP,
因为此时可以很容易地用图来描述变量之间的关系.</p>
<p>作为搜索问题的子集, 解决 CSP 的最简单的方式当然是 DFS,
或者说回溯(backtracking), 此时不关注变量赋值的顺序,
即认为变量赋值这一操作是可交换的.</p>
<p>设变量 <span class="math inline">\(X\)</span> 的值域为 <span
class="math inline">\(D_X\)</span>, 初始情况下默认 <span
class="math inline">\(|D_X|=d\)</span>. 以地图染色为例子, 设 <span
class="math inline">\(D=\{\rm red, blue, yellow\}\)</span>,
相邻的两块地图颜色需要不同, 下面是原图和抽象出来的 graph.</p>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308101032224.png" style="zoom:50%;" /></p>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308101031614.png" style="zoom:50%;" /></p>
<h1 id="提高回溯的效率">提高回溯的效率</h1>
<p>搜索过程中需要枚举不同的变量以及变量不同的取值,
枚举的顺序实际上对效率有较大的影响, 对于下个状态选择哪个变量赋值,
给选择的变量赋哪个值, 以及能否更早地剪枝以避免不必要的搜索,
采用以下策略.</p>
<p>对于变量:</p>
<ul>
<li>Most constrained variable. 即选择"被约束得最厉害的"那个变量,
或者说合法(指不违反约束)取值数目最小的变量. 比如下图在涂过绿色之后, 城市
SA 只剩蓝色这一种选择, 那么优先给 SA 涂上蓝色.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308101035585.png" style="zoom:50%;" /></p>
<ul>
<li>Most constraining variable. 选择变量之后,
剩下的变量"被约束得最厉害", 即使剩下的变量的合法取值变得最少.
这样做的是因为所有的变量都必须被赋值, 可以更早地搜索到不成立的情形.
比如在初始状态, 城市 SA 是最好的选择, 因为 SA 的颜色确定之后, WA, NT, Q,
NSW, V 的合法取值均减一, 是减少的最多的.</li>
</ul>
<p>对于变量的取值:</p>
<ul>
<li>Least constraining value.
选择的值对剩余变量的合法取值的减少应该最小.
这样做可以减少对变量取值的尝试, 减少不必要的分支. 比如下面的情况,
应优先给 Q 涂红色而不是蓝色, 否则会导致 SA 没有合法的颜色可选.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308101038831.png" style="zoom:50%;" /></p>
<h1 id="forward-checking">Forward Checking</h1>
<p>Forward Checking 是一种进一步减少搜索树规模的技术,
在给某个变量赋值之后, 在进行下一步搜索之前,
可以根据约束先一步减少未赋值变量合法取值的数量, 这称为<strong>一次
check</strong>, 若 check 以后出现了仅剩一种取值的变量 <span
class="math inline">\(X\)</span> , 那么可以根据 <span
class="math inline">\(X\)</span>
这唯一的取值继续根据约束减少剩余变量的合法取值的数量,
这称为<strong>传播(propagation)</strong>.</p>
<p>需要注意 forward checking propagation 并不能提前检测到不成立的情形,
当传播完毕后, 搜索还需要继续进行才能确定是否要终止这一分支的搜索.</p>
<h1 id="arc-consistency">Arc Consistency</h1>
<p><strong>弧一致性检验</strong>主要是在 binary-CSP 中应用, 对于一个
binary-CSP, 以变量为顶点, 约束为弧, 构造有向图 <span
class="math inline">\(G=(V,E)\)</span>, 这里 <span
class="math inline">\(|V|\)</span> 相当于变量数, <span
class="math inline">\(|E|\)</span> 相当于约束数. 对于其中的两个变量
<span class="math inline">\(X,Y\)</span>, 若 <span
class="math inline">\(X,Y\)</span> 出现在同一约束中则 <span
class="math inline">\((X,Y)\in E\land (Y,X)\in E\)</span>, 那么弧 <span
class="math inline">\((X,Y)\)</span> 是一致的当且仅当对于任意 <span
class="math inline">\(x\in D_X\)</span> 都存在合法的 <span
class="math inline">\(y\in D_Y\)</span> 可以取到, 如果某个 <span
class="math inline">\(x\)</span> 使得所有 <span
class="math inline">\(y\in D_Y\)</span> 都不能取到, 那么这个 <span
class="math inline">\(x\)</span> 就没必要再选了, 可以直接删去, 此时
<span class="math inline">\(X\)</span> 的取值丢失了一个值后,
需要重新检查 <span class="math inline">\(X\)</span> 的邻居 .
当存在不一致的弧时, 就说明当前状态已经不满足约束, 是一个失败的状态, 算法
AC-3 可以用来找到一个状态是否存在不一致的弧.</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308091255691.png" /></p>
<p>这个算法维护一个队列存弧, 每次取队首元素 <span
class="math inline">\((X_i,X_j)\)</span> 判断根据当前状态是否可以修改
<span class="math inline">\(X_i\)</span> 的取值 <span
class="math inline">\(D_i\)</span>, 如果修改了且 <span
class="math inline">\(X_i\)</span>
不存在合法取值就意味着找到了不一致的弧, 否则就要重新check <span
class="math inline">\(X_i\)</span> 与其邻居的弧一致性, 因此就将弧 <span
class="math inline">\((X_k,X_i)(X_k\in N(X_i)\backslash\{X_j\})\)</span>
加到队列中. 根据当前状态以及弧 <span
class="math inline">\((X_i,X_j)\)</span> 修改 <span
class="math inline">\(X_i\)</span> 的取值, 只需要删去 <span
class="math inline">\(x\in D_i\)</span> 满足 <span
class="math inline">\(\forall y\in D_j,(x,y)\)</span> 都不满足约束,
如果不存在这样的 <span class="math inline">\(x\)</span>,
则不做任何修改.</p>
<p>对于任意两个变量, 检查它们的弧一致性需要枚举两个变量的所有取值,
这一步骤的复杂度为 <span class="math inline">\(O(d^2)\)</span>, 于是
AC-3算法的复杂度为 <span class="math inline">\(O(|E|d^3)\)</span>.</p>
<p>相比 forward checking, arc consistency
可以更早地检测到当前分支的失败; 同时AC-3算法无法发现所有的不一致的弧,
比如下图的情况:</p>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308101043893.png" style="zoom:50%;" /></p>
<p>这显然是一种不合法的情况, 不管怎么取值都会有两个相邻的取到相邻的颜色,
但是弧一致性检验只能两两之间检验.</p>
<h1 id="k-consistency"><span
class="math inline">\(k\)</span>-consistency</h1>
<p>如果一个 CSP 问题, 对于它的任意 <span
class="math inline">\(k-1\)</span> 个变量任意地合法赋值, 第 <span
class="math inline">\(k\)</span> 个变量都存在合法的值可以被赋予,
那么就称该 CSP 问题是 <span class="math inline">\(k\)</span>-consistent
的. 显然 <span class="math inline">\(1\)</span>-consisteny 是 node
consistency, <span class="math inline">\(2\)</span>-consistency 是 arc
consistency.</p>
<h1 id="tree-structured-csps">Tree-structured CSPs</h1>
<p>当上文的 binary-CSP 对应的图 <span class="math inline">\(G\)</span>
是一棵树, 那么该 CSP 可以在 <span class="math inline">\(O(nd^2)\)</span>
的时间内解决, 而一般的 CSP 的最坏时间复杂度为 <span
class="math inline">\(O(d^n)\)</span>. 这是一个 DP 算法:</p>
<p>随机选择一个结点作为根节点,
按照拓扑排序得到一个节点序列<strong>保证父节点在子节点</strong>之前,
接着倒序遍历得到的序列, 对 <span
class="math inline">\((\mathrm{fa}(x),x)\)</span> 进行弧一致性检验,
删去一些值, 那么再正序遍历, 给每一个结点 <span
class="math inline">\(x\)</span> 赋一个与其父节点 <span
class="math inline">\(\mathrm{fa}(x)\)</span> 的值相容的值即可,
这是一定可以做到的,
因为前面做过弧一致性检验后保证了对于父节点的任意一个取值,
子结点至少有一个合法取值.</p>
<p>由于大部分图不是树形结构, 但是对于比较接近树结构的图,
我们可以在图中找到最少的点(这是NPC的),
删去这些点之后使得剩下的子图成为一颗树(比如删去城市 SA),
那么就可以用上面的算法来解决, 对于删去的点直接枚举每个点的所有取值即可,
设删去的点的数目为 <span class="math inline">\(c\)</span>, 那么复杂度为
<span class="math inline">\(O(d^c(n-c)d^2)\)</span>, 我们希望 <span
class="math inline">\(c\)</span> 比较小.</p>
<h2 id="tree-decomposition">Tree decomposition</h2>
<p>为了使用 tree-structured CSPs 的复杂度较低的算法, 除了上面的删点手段,
还可以使用 Tree decomposition,
即组合若干相邻节点称为一个"大结点"(meganode), 如下图所示,
同一个结点可以在不同的"大节点"中出现, 使 meganode 之间成为一棵树,
且要保证其赋值的一致性.</p>
<p>定义树宽为 <span class="math inline">\(w= \max
|\mathrm{meganode}|-1\)</span>, 当树宽为 <span
class="math inline">\(1\)</span> 时原图为树.</p>
<p>在 <span class="math inline">\(G\)</span> 中, 若已知 <span
class="math inline">\(\deg(v)\)</span>, 则在 tree decomposition
得到的树中, <span class="math inline">\(v\)</span> 所在的 meganode
的数量为 <span class="math inline">\(\deg(v)-1\)</span> 且这些 megenode
恰好可以连成一条 path.</p>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308101210596.png" style="zoom: 50%;" /></p>
<p>下面是另一个例子:</p>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308142052499.png" style="zoom:50%;" /></p>
<p>处理的时候先处理每个 meganode, 再使用 tree-structured CSPs
的算法处理整棵树即可. 那么复杂度为 <span
class="math inline">\(O(nd^{w+1})\)</span>, 对任意图,
找到它的最小树宽的问题是 NPC 的, 可以用启发式算法找到一个相对小的.</p>
<h1 id="local-search-for-csps">Local Search for CSPs</h1>
<p>对于一个 CSP, 可以随机给一种赋值方案, 这大概率会有违反约束的情况,
local search 指的是通过不断调整不同变量的值来消除违反约束的部分,
最后得到一个可行解.</p>
<h1 id="习题">习题</h1>
<p><strong>6.4</strong> Give precise formulations for each of the
following as constraint satisfaction problems:</p>
<ol type="a">
<li><p>Rectilinear floor-planning: find non-overlapping places in a
large rectangle for a number of smaller rectangles.</p></li>
<li><p>Class scheduling: There is a fixed number of professors and
classrooms, a list of classes to be offered, and a list of possible time
slots for classes. Each professor has a set of classes that he or she
can teach.</p></li>
<li><p>Hamiltonian tour: given a network of cities connected by roads,
choose an order to visit all cities in a country without repeating
any.</p></li>
</ol>
<blockquote>
<p>Find a permutation of <span
class="math inline">\(\{1,\cdots,n\}\)</span> such that <span
class="math inline">\(\forall j\ne k,v_{i_j}\in N(v_{i_k})\)</span>.</p>
</blockquote>
<p><strong>6.6</strong> Show how a single ternary constraint such as
“<span class="math inline">\(A + B = C\)</span>” can be turned into
three binary constraints by using an auxiliary variable. You may assume
finite domains. (Hint: Consider a new variable that takes on values that
are pairs of other values, and consider constraints such as “X is the
first element of the pair Y .”) Next, show how constraints with more
than three variables can be treated similarly. Finally, show how unary
constraints can be eliminated by altering the domains of variables. This
completes the demonstration that any CSP can be transformed into a CSP
with only binary constraints.</p>
<blockquote>
<p>这个问题最终要求证明任意的 CSP 问题都可以转化为 binary-CSP 问题.</p>
<p>根据 hint, 令 <span class="math inline">\(X=(A,B)\in D^2\)</span>,
那么约束 <span class="math inline">\(A+B=C\)</span> 可以转化为如下的三个
binary constraint: <span class="math display">\[
\begin{cases}
\langle X,(1,1)\rangle=C\\
A \text{ is the first element of }X\\
B \text{ is the second element of }X
\end{cases}
\]</span> 对于更多变量的约束, 比如 <span
class="math inline">\(f(X_1,\cdots,X_n)=0\)</span>,
当表达式为线性或者二次型时还能采用上述方法, 但是如果约束比较复杂,
还能怎么办呢?</p>
</blockquote>
<p><strong>6.13</strong> AC-3 puts back on the queue every arc <span
class="math inline">\((X_k, X_i)\)</span> whenever any value is deleted
from the domain of <span class="math inline">\(X_i\)</span>, even if
each value of <span class="math inline">\(X_k\)</span> is consistent
with several remaining values of <span
class="math inline">\(X_i\)</span>. Suppose that, for every arc <span
class="math inline">\((X_k, X_i)\)</span>, we keep track of the number
of remaining values of <span class="math inline">\(X_i\)</span> that are
consistent with each value of <span class="math inline">\(X_k\)</span>.
Explain how to update these numbers efficiently and hence show that arc
consistency can be enforced in total time <span
class="math inline">\(O(n^2d^2)\)</span>.</p>
<p><strong>6.14</strong> The TREE-CSP-SOLVER (Figure 6.10) makes arcs
consistent starting at the leaves and working backwards towards the
root. Why does it do that? What would happen if it went in the opposite
direction?</p>
<blockquote>
<p>弧一致性检验要求当某个结点的合法取值被删去之后要 recheck 其邻居,
对于树形结构的 CSP, 每次删去的都是父节点的取值, 倒序遍历时,
父节点的祖先还没有被更新过, 可以在遍历的过程中一次更新,
而其儿子不需要再更新; 如果正序遍历, 那么删去某个父节点的值后,
还要再检查该父节点的父亲结点, 这个检查有可能会继续传播直到根节点,
造成了大量的开销. 因此倒序遍历保证了每个结点只 check 了一次.</p>
</blockquote>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/31/essay/vscode-wsl-permission/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/31/essay/vscode-wsl-permission/" class="post-title-link" itemprop="url">VScode连接WSL2后无权限修改</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-31 12:05:41" itemprop="dateCreated datePublished" datetime="2023-07-31T12:05:41+08:00">2023-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-10 23:21:57" itemprop="dateModified" datetime="2023-08-10T23:21:57+08:00">2023-08-10</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/31/essay/vscode-wsl-permission/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/31/essay/vscode-wsl-permission/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>647</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>执行下面的命令即可:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R username path</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R xubaoduo /home/xubaoduo/project</span><br></pre></td></tr></table></figure>
<h2 id="reference"><strong>Reference</strong></h2>
<p><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/66496890/vs-code-nopermissions-filesystemerror-error-eacces-permission-denied">https://stackoverflow.com/questions/66496890/vs-code-nopermissions-filesystemerror-error-eacces-permission-denied</a></p>
<h1 id="wsl2安装docker遇到的问题">WSL2安装Docker遇到的问题</h1>
<p>在官网下载运行安装打开后出现下面的情况:</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202307311712344.png" /></p>
<p>以管理员权限运行cmd后, 输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path - C:\Windows\system32</span><br></pre></td></tr></table></figure>
<p>再打开就解决了.</p>
<p>在WSL2的CLI中输入 <code>docker --veriosn</code> 后提示 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The command &#x27;docker&#x27; could not be found in this WSL 2 distro.</span><br><span class="line">We recommend to activate the WSL integration in Docker Desktop settings.</span><br><span class="line"></span><br><span class="line">For details about using Docker Desktop with WSL 2, visit:</span><br><span class="line"></span><br><span class="line">https://docs.docker.com/go/wsl2/</span><br></pre></td></tr></table></figure>
只需要运行下面两句安装即可:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>
<blockquote>
<p>微软商店的 Windows Terminal 确实挺好看的.</p>
</blockquote>
<h2 id="reference-1">Reference</h2>
<p>ChatGPT以及StackOverflow.</p>
<h1 id="git-常见命令">git 常见命令</h1>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/note/56524">这里。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/30/abbr-term/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/30/abbr-term/" class="post-title-link" itemprop="url">术语缩写汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-07-30 10:46:32 / Modified: 23:01:41" itemprop="dateCreated datePublished" datetime="2023-07-30T10:46:32+08:00">2023-07-30</time>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/30/abbr-term/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/30/abbr-term/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/29/seminar/july2023/search-strategy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/29/seminar/july2023/search-strategy/" class="post-title-link" itemprop="url">搜索策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-29 20:46:39" itemprop="dateCreated datePublished" datetime="2023-07-29T20:46:39+08:00">2023-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-30 16:26:28" itemprop="dateModified" datetime="2023-07-30T16:26:28+08:00">2023-07-30</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2023/07/29/seminar/july2023/search-strategy/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/07/29/seminar/july2023/search-strategy/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!--<p>一个well-defined的搜索问题包括下面的组成部分：</p>
<ul>
<li>初始状态</li>
<li>操作算子: 用于状态转换</li>
<li>目标</li>
<li>路径代价函数</li>
</ul>
<p>即从初始状态出发, 扫描操作算子集,
选取适当的操作算子作用在初始状态上得到新的状态,
新的状态满足目标时终止搜索, 反之以新的状态作为当前状态;
如果最终还需要搜索路径, 那么就在搜索的时候维护搜索树中每个状态的父节点.
在搜索过程中, 我们关注能否找到解, 解的质量, 时空复杂度.</p>
<p>根据搜索方向, 搜索策略可以分为正向搜索和逆向搜索:</p>
<ul>
<li>正向搜索: 实际上就是上面所叙述的搜索过程.</li>
<li>逆向搜索: 当操作算子可逆时, 可以从目标出发,
寻找<strong>能产生该目标的操作算子</strong>以及<strong>产生该操作算子需要的条件</strong>.
按照该策略不断进行, 直到找到问题给定的条件即可.</li>
</ul>
<p>根据搜索过程中是否用与问题有关的信息分为盲目搜索和启发式搜索,
启发式搜索可以看作是一种基于经验的贪心策略.</p>
<h1 id="回溯">回溯</h1>
<p>回溯策略就是从初始状态出发, 不断试探寻找可行的路径,
如果遇到了<strong>不可解点</strong>时就回溯到距离最近的父节点,
判断其是否还有其他子节点未被扩展.</p>
<blockquote>
<p>回溯等同于DFS吗?</p>
<p>如果考虑严格定义的话, DFS本身是在图这一抽象出来的结构上使用的算法;
而回溯则是在拥有上述特征的问题中使用的(或者说,
回溯是搜索问题的特征空间映射得到的的树结构上的DFS),
两者的使用场景其实不太一样. 不过在实际使用的时候,
对DFS和回溯这两个名词其实并没有做明显的区分,
在措辞表达方面可能DFS用得更多一些; 除此之外,
再深究一下回溯定义中的"遇到了不可解点就回溯"这一策略,
这实际上是一种剪枝, 即可以认为回溯相比一般的DFS多了剪枝.
反正没有必要做区分.</p>
</blockquote>
<h1 id="bfs和dfs的一些值得注意的地方">BFS和DFS的一些值得注意的地方</h1>
<p>1: BFS一定能找到最优解而DFS不一定. 这很好理解,
如果问题对应的搜索树不是有限的, 那么DFS将一直搜下去,
但显然一层一层搜索的BFS一定可以找到最优解.</p>
<p>2: 一个搜索问题必须具备某种特征才能使用BFS求解. 设 <span
class="math inline">\(g(N)\)</span> 表示从起点到节点 <span
class="math inline">\(N\)</span>
的代价(就是文章最开始的<strong>路径代价函数</strong>), 其中 <span
class="math inline">\(N\)</span> 在搜索树中的层数是 <span
class="math inline">\(d\)</span> , 那么某个问题能使用BFS求解当且仅当
<strong><span class="math inline">\(g\)</span> 关于 <span
class="math inline">\(d\)</span> 是递增的</strong>.
比较经典的例子是Dijkstra算法无法在有负权环的图上应用,
因为Dijkstra算法本质上就是BFS, 若出现了负权环,
那么就可以在负权环上一直搜索下去(搜索深度增加)而代价始终不增,
也就没有最优解了.</p>
<p>3: DFS的一些改进. 主要是迭代加深搜索, 这个很容易想到,
可能在做题的时候就不经意间使用了: 设定一个深度限制, 记录当前深度,
每迭代一次当前深度加一, 当达到限制还没有找到最优解时便回溯.</p>
<h1 id="mathrmaast-和-mathrmidaast"><span
class="math inline">\(\mathrm{A}^{\ast}\)</span> 和 <span
class="math inline">\(\mathrm{IDA}^{\ast}\)</span></h1>
<p>启发式搜索本质上是基于经验或直觉在每一步选择操作算子时都选择较优的,
达到缩小状态空间的目的. 由于严重依赖经验或直觉,
因此启发式算法往往只能得到次优解 , 甚至一无所获.</p>
<p>对于待搜索节点 <span class="math inline">\(n\)</span> ,
定义它的估价函数 <span class="math inline">\(f(n)\)</span>
表示它的"有希望"程度, 那么在搜索时就优先搜索有希望程度更大的的状态; 当然
<span class="math inline">\(f(n)\)</span> 也可以是"没希望程度",
那么就优先搜索没希望程度更小的状态, 此时搜索的过程相当于最小化 <span
class="math inline">\(f(n)\)</span> 的过程, 这与机器学习中的 loss
function 是一样的, 或者说, <span class="math inline">\(f(n)\)</span>
本身就是一个 loss function. 实现这种算法往往要使用优先队列. Dijkstra
算法是一个典型的符合该搜索过程的算法, 有时候会把上面的算法称为 A 算法.
搜索过程中碰到重复结点的处理手段类似于 Dijkstra 算法.</p>
<p>对不同的问题 <span class="math inline">\(f(n)\)</span>
的结构不尽相同, 但都可以写成 <span
class="math inline">\(f(n)=g(n)+h(n)\)</span> 的形式, 其中 <span
class="math inline">\(g(n)\)</span> 表示从起点到结点 <span
class="math inline">\(n\)</span> 搜索所耗费的实际代价,
它衡量了状态在搜索图/树中的深度, <span
class="math inline">\(h(n)\)</span> 为从结点 <span
class="math inline">\(n\)</span>
到目标状态的最佳路径的<strong>估计代价</strong>. <span
class="math inline">\(g(n)\)</span> 在搜索的过程中很容易就能确定, <span
class="math inline">\(h(n)\)</span> 需要根据题目的具体信息来设计,
不同方案会带来显著不同的效果. <span class="math inline">\(g(n)\)</span>
和 <span class="math inline">\(h(n)\)</span>
的大小决定了搜索过程中盲目搜索和基于经验的搜索所占的比例, <span
class="math inline">\(g(n)\gg h(n)\)</span>
时有利于搜索的完备性但状态空间比较大时代价会很高; <span
class="math inline">\(h(n)\gg g(n)\)</span>
时对于比较复杂的问题往往只能得到次优解但效率会有显著提升.</p>
<p>用 Dijkstra 算法求解最短路时 <span
class="math inline">\(h(n)=0\)</span>, 此时必然能找到最优解.</p>
<p>不能保证 A 算法能得到最优解, 能否加上一些条件使其必定能得到最优解呢?
<span class="math inline">\(\mathrm{A}^{\ast}\)</span> 算法是这样的算法.
设 <span class="math inline">\(h^{\ast}(n)\)</span> 表示结点 <span
class="math inline">\(n\)</span> 到目标状态的最优路径的代价,
若对所有节点 <span class="math inline">\(n\)</span> 都有 <span
class="math inline">\(h(n)\le h^{\ast}(n)\)</span> 则 A
算法必定能在有限步搜索到最优的解, 这时它称为 <span
class="math inline">\(\mathrm{A}^{\ast}\)</span> 算法.</p>
<p>值得注意的是 <span class="math inline">\(\mathrm{A}^{\ast}\)</span>
算法仍然是一类算法, 不同的启发策略仍然有优劣, 那么需要一些标准:</p>
<ul>
<li>完备性: 算法是否能在有限步能搜索到最优解. 所有的 <span
class="math inline">\(\mathrm{A}^{\ast}\)</span> 算法都满足.</li>
<li>单调性: 启发函数 <span class="math inline">\(h\)</span> 满足(1) 当
<span class="math inline">\(n_i\)</span> 是 <span
class="math inline">\(n_j\)</span> 的子节点时有 <span
class="math inline">\(h(n_i)-h(n_j)\le \mathrm{cost}(n_j,n_i)\)</span>;
(2) <span class="math inline">\(h(n_{\mathrm{goal}})=0\)</span>.</li>
<li>信息性. 当 <span class="math inline">\(h_2(n)\ge h_1(n)\)</span>
恒成立时称启发策略 <span class="math inline">\(h_2\)</span> 相比 <span
class="math inline">\(h_1\)</span> 具有更多的信息性. <span
class="math inline">\(h\)</span>
越大相当于用了题目中的更多信息来使得状态空间更小,
当然更多的信息性带来的计算代价可能会与减小状态空间所带来的益处抵消.</li>
</ul>
<p><span class="math inline">\(\mathrm{A}^{\ast}\)</span>
算法完备性的证明:</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/20230730120653.png" /></p>
<p>类似于迭代加深搜索, 可以提出 Iterative-deepening <span
class="math inline">\(\mathrm{A}^{\ast}\)</span> 即 <span
class="math inline">\(\mathrm{IDA}^{\ast}\)</span>.
不同于迭代加深搜索的深度限制, <span
class="math inline">\(\mathrm{IDA}^{\ast}\)</span> 给 <span
class="math inline">\(f\)</span> 设置了一个限制 <span
class="math inline">\(f&#39;\)</span>, <span
class="math inline">\(f&#39;\)</span> 初始化为 <span
class="math inline">\(f(\mathrm{root})\)</span>, 即初始状态(根结点)
对应的估价函数值; 接着不断地以 <span
class="math inline">\(f&#39;\)</span> 作为限制进行DFS,
找到最优解则返回最优解, 否则返回所有满足 <span
class="math inline">\(f(n)&gt;f&#39;\)</span> 的 <span
class="math inline">\(f(n)\)</span> 的最小值,
或者说搜索终止边界处的结点的估价函数值中的最小值, 依次更新 <span
class="math inline">\(f&#39;\)</span>, 下面是伪代码:</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/20230730160830.png" /></p>
<p>在 <span class="math inline">\(\mathrm{IAD}^{\ast}\)</span>
的基础上对使用的内存做改进可以得到 <span
class="math inline">\(\mathrm{SMA}^{\ast}\)</span>,
基本思路是遗忘掉一些结点,
同时需要用到其他结点的估价函数值来更新当前结点的估价函数值.</p>
-->
          <p></p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Baoduo Xu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa-thin fa-atom-simple"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Baoduo Xu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">165k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">2:30</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    window.MathJax = {
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '5tA44WzshqSYTe1o3UZ69rbG-gzGzoHsz',
      appKey     : 'mKQ1yQvoXZgY9Fhki3p08I8o',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
