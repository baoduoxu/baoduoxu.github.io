<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/infinity-solid.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/infinity-solid.svg">
  <link rel="mask-icon" href="/images/infinity-solid.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Palatino:300,300italic,400,400italic,700,700italic%7CCascadia+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="[object Object]">

<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":200},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="概述, 课程要求等.">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统概述">
<meta property="og:url" content="http://example.com/2023/07/25/junior_1_semester/OS/1-introduction/index.html">
<meta property="og:site_name" content="XBD">
<meta property="og:description" content="概述, 课程要求等.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308311103888.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202309071056621.png">
<meta property="og:image" content="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202311082143060.png">
<meta property="article:published_time" content="2023-07-25T03:18:46.323Z">
<meta property="article:modified_time" content="2023-12-22T08:56:21.189Z">
<meta property="article:author" content="Baoduo Xu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308311103888.png">


<link rel="canonical" href="http://example.com/2023/07/25/junior_1_semester/OS/1-introduction/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/07/25/junior_1_semester/OS/1-introduction/","path":"2023/07/25/junior_1_semester/OS/1-introduction/","title":"操作系统概述"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统概述 | XBD</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">XBD</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Everything will end up being TRIVIAL.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E8%A6%81%E6%B1%82"><span class="nav-number">1.</span> <span class="nav-text">课程要求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8B%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.</span> <span class="nav-text">课程主要内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">可扩展性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-number">3.</span> <span class="nav-text">发展历史</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%AE%89%E5%85%A8"><span class="nav-number">3.3.</span> <span class="nav-text">信息保护和安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">调度和资源管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">3.5.</span> <span class="nav-text">现代操作系统的特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E6%80%A7"><span class="nav-number">3.6.</span> <span class="nav-text">容错性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%A4%9A%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="nav-number">3.7.</span> <span class="nav-text">多处理器和多核操作系统设计考虑因素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-1"><span class="nav-number">4.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">4.1.</span> <span class="nav-text">进程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">进程的两状态模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">五状态模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="nav-number">4.2.</span> <span class="nav-text">进程描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unix-svr4"><span class="nav-number">4.4.</span> <span class="nav-text">UNIX SVR4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">4.4.1.</span> <span class="nav-text">fork()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">为什么有线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%8E%E4%BC%98%E7%82%B9"><span class="nav-number">5.2.</span> <span class="nav-text">线程的特征与优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB"><span class="nav-number">5.3.</span> <span class="nav-text">线程分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="nav-number">6.</span> <span class="nav-text">单处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">重要的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fcfs"><span class="nav-number">6.1.1.</span> <span class="nav-text">FCFS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="nav-number">7.</span> <span class="nav-text">实时系统与实时调度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">8.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">8.1.</span> <span class="nav-text">并发的原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5"><span class="nav-number">9.</span> <span class="nav-text">互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">软件方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">硬件方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">10.</span> <span class="nav-text">信号量实现同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E4%BA%92%E6%96%A5-%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">10.1.</span> <span class="nav-text">用信号量解决互斥-同步问题的一般步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">10.2.</span> <span class="nav-text">生产者&#x2F;消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%A9%BA%E9%97%B4%E6%95%B0%E4%B8%BA-nnge-2"><span class="nav-number">10.2.1.</span> <span class="nav-text">缓冲区的空间数为 \(n(n\ge 2)\)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%A9%BA%E9%97%B4%E6%95%B0%E4%B8%BA-1"><span class="nav-number">10.2.2.</span> <span class="nav-text">缓冲区的空间数为 1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">11.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="nav-number">11.1.</span> <span class="nav-text">解决死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">11.1.1.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">11.1.2.</span> <span class="nav-text">死锁避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">11.1.3.</span> <span class="nav-text">死锁检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="nav-number">11.1.3.1.</span> <span class="nav-text">死锁解除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">11.2.</span> <span class="nav-text">哲学家就餐问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="nav-number">12.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5"><span class="nav-number">12.1.</span> <span class="nav-text">基本分页和分段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">12.2.</span> <span class="nav-text">虚拟内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">13.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unix-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">13.1.</span> <span class="nav-text">UNIX 文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="nav-number">13.1.1.</span> <span class="nav-text">索引结点结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D"><span class="nav-number">13.1.2.</span> <span class="nav-text">文件分配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A1"><span class="nav-number">14.</span> <span class="nav-text">作业1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A2"><span class="nav-number">15.</span> <span class="nav-text">作业2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A3"><span class="nav-number">16.</span> <span class="nav-text">作业3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A4"><span class="nav-number">17.</span> <span class="nav-text">作业4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A5"><span class="nav-number">18.</span> <span class="nav-text">作业5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A6"><span class="nav-number">19.</span> <span class="nav-text">作业6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A7"><span class="nav-number">20.</span> <span class="nav-text">作业7</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A8"><span class="nav-number">21.</span> <span class="nav-text">作业8</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#project"><span class="nav-number">22.</span> <span class="nav-text">Project</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2018-2019%E5%AD%A6%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%AD%A6%E6%9C%9F%E6%9C%9F%E4%B8%AD%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7%EF%BD%81%E5%8D%B7"><span class="nav-number">23.</span> <span class="nav-text">《计算机操作系统》2018-2019学年第二学期期中考试试卷（Ａ卷）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C"><span class="nav-number">24.</span> <span class="nav-text">实验</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Baoduo Xu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="/baoduo_xu@foxmail.com" title="E-Mail → baoduo_xu@foxmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/ta-mei-yu-zhi-jian-de-wen-rou" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;ta-mei-yu-zhi-jian-de-wen-rou" rel="noopener me" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/25/junior_1_semester/OS/1-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Baoduo Xu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XBD">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统概述 | XBD">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统概述
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-25 11:18:46" itemprop="dateCreated datePublished" datetime="2023-07-25T11:18:46+08:00">2023-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-22 16:56:21" itemprop="dateModified" datetime="2023-12-22T16:56:21+08:00">2023-12-22</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>19 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>希望能坚持。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/">xv6-book</a></p>
<p><a
target="_blank" rel="noopener" href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">course</a></p>
<h1 id="课程要求">课程要求</h1>
<figure>
<img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308291031258.jpg"
alt="课时构成" />
<figcaption aria-hidden="true">课时构成</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308291033840.jpg"
alt="成绩组成" />
<figcaption aria-hidden="true">成绩组成</figcaption>
</figure>
<h2 id="课程主要内容">课程主要内容</h2>
<ol type="1">
<li>操作系统概述</li>
<li>进程管理</li>
<li>存储管理</li>
<li>设备管理</li>
<li>文件管理</li>
</ol>
<h1 id="概述">概述</h1>
<p>操作系统的三个目标：</p>
<ul>
<li>方便: 使计算机更容易使用.</li>
<li>有效: 以更有效的方式使用计算机系统资源.</li>
<li>扩展能力: 在不妨碍服务的前提下, 有效地开发,
测试和引入新的系统功能.</li>
</ul>
<p>它提供了下面的服务:</p>
<ul>
<li>程序开发</li>
<li>程序运行</li>
<li>I/O 设备访问</li>
<li>文件访问控制</li>
<li>系统访问</li>
<li>错误检测和响应</li>
<li>记账</li>
</ul>
<p>三种重要接口是 ISA, ABI, API.</p>
<p>由于计算机可以看作是一组资源, 因此操作系统可以看作是资源管理器,
控制计算机的基本功能, 但是是一种不同寻常的控制:</p>
<ul>
<li>操作系统是由处理器执行的一段程序或者一组程序</li>
<li>操作系统经常<strong>会<em>释放</em>控制</strong>,
而且<strong>必须依赖处理器 (processor) 才能恢复控制</strong>.
操作系统控制处理器使用其他系统资源, 并控制其他程序的执行时机.
其实就是不同程序对处理器的占用调度分配.</li>
</ul>
<p>因此 OS 需要完成的资源管理包括:</p>
<ul>
<li><p><strong>内存</strong>的分配管理</p></li>
<li><p><strong>I/O</strong>的访问控制</p></li>
<li><p>对<strong>文件</strong>的访问控制和使用</p></li>
<li><p>对<strong>处理器</strong>的分配</p></li>
</ul>
<p>操作系统通过接口向用户提供服务.</p>
<h2 id="可扩展性">可扩展性</h2>
<p>操作系统因下面的特性而不断发展:</p>
<ul>
<li>硬件升级和新型硬件的出现</li>
<li>新服务</li>
<li>纠错: 引入<strong>补丁</strong>(patch)纠错. ( patch
本身也会引入新的错误 )</li>
</ul>
<h1 id="发展历史">发展历史</h1>
<p>监控程序的功能:</p>
<p>作业的自动续接</p>
<ul>
<li>内存保护</li>
<li>定时器</li>
<li>特权指令</li>
<li>中断</li>
</ul>
<p>两种运行模式:</p>
<ul>
<li>用户模式: 不允许执行特权指令</li>
<li>内核模式: 可执行特权指令以及访问受保护的内存区域.</li>
</ul>
<blockquote>
<p>1: 为什么要有两种运行模式(user mode 和 kernel mode)?</p>
<p>答: 为了安全性(保护操作系统重要的数据结构,
防止在用户模式下访问到关键的内存执行到关键的指令,
而对操作系统造成破坏)/错误隔离/性能优化.</p>
<p>2: 如何知道当前是哪种模式?</p>
<p>答: 通过特殊的处理器状态标志(存在寄存器中)以及硬件机制来判断.
类似的有状态字寄存器PSW.</p>
</blockquote>
<p>batch processing 指的是一批作业要能自动处理完成,
也就是完成一个作业之后要能够自动续接.</p>
<p>简单批处理系统通过串行处理, 是 <strong>读-执行指令-写</strong>
的串行序列(处理器必须等待I/O完成后才能继续处理),
实际利用的时间只有执行指令的时间, 其他时间都在等I/O,
而执行指令的速度非常快, 导致系统利用率非常低.</p>
<p>多道批处理(batch processing)系统就是<strong>并发</strong>处理,
处理器在空闲时间去执行其他指令. 这其中比较重要的硬件是I/O中断和DMA.
除此之外, 由于需要并行处理, 因此需要将待执行的若干作业存储起来,
需要<strong>内存管理</strong>,
也需要设计合适的<strong>调度算法</strong>(作业调度程序负责).</p>
<blockquote>
<p>1: 并发和并行的区别:</p>
<ul>
<li>并发指的是在<strong>一段时间</strong>内可以同时执行若干作业.</li>
<li>并行指的是某一时刻可以同时执行.</li>
</ul>
<p>并行可以看作是并发的子集.</p>
<p>2: 为什么在多道批处理中需要有中断和DMA的支持?</p>
<ul>
<li>中断: 当I/O完成后操作系统会正在进行I/O操作的进程发出I/O中断,
处理器被中断, 操作系统接管对处理器的控制权.</li>
<li>DMA: 由于作业存在存储器中, 因此需要频繁地直接访问存储器,
而DMA可以<strong>允许外设直接访问系统内存</strong>, 不需要CPU接入,
可以大大提高数据传输的效率.</li>
</ul>
<p>计组没学好是这样的😭</p>
</blockquote>
<p><strong>分时系统</strong>:</p>
<ul>
<li>采用多道程序设计技术处理多个交互作业</li>
<li>多个用户共享处理器时间</li>
<li>多个用户可以通过终端同时访问系统(操作系统控制<strong>用户程序</strong>在很短的时间内<strong>交替</strong>执行)</li>
<li>时间片技术.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202308311103888.png" style="zoom: 50%;" /></p>
<blockquote>
<p>分时与多道的联系是什么? 分时是在多道的基础上设计的,
都是为了提高处理器利用率.</p>
</blockquote>
<h2 id="进程">进程</h2>
<p>1: 什么是进程?</p>
<ul>
<li>一个<strong>正在执行</strong>的程序.</li>
<li>计算机中<strong>正在运行</strong>的程序的一个<strong>实体</strong></li>
<li>可分配给处理器并由处理器执行的一个实体</li>
<li>由 一个单一顺序线程, 一个当前状态, 一组相关系统资源
所<strong>表征</strong>的活动单元. 表征是什么意思?
活动单元又是什么意思?</li>
</ul>
<p>可以看到进程是一个动态的概念.</p>
<blockquote>
<ol type="1">
<li><p>什么是线程?</p>
<p>答:
线程是计算机程序中的一种执行单元，它是进程的一部分。一个进程可以包含多个线程，每个线程独立执行特定的任务。与进程不同的是，线程共享相同的内存空间，可以直接访问进程的资源和数据。</p></li>
<li><p>什么叫做表征? 什么叫做活动单元?</p>
<p>答: 表征就是表示的意思.</p></li>
</ol>
</blockquote>
<p>2: 为什么要有进程? (实际上是类似于数据库中事务的特性)
可能会存在下面的问题:</p>
<ul>
<li>不正确的同步</li>
<li>失败的互斥</li>
<li>不确定的程序操作</li>
<li>死锁</li>
</ul>
<p>3: 进程的组成.</p>
<ul>
<li>一段可执行的程序</li>
<li>程序所需要的数据</li>
<li>程序执行的<strong>上下文(进程状态,
操纵系统用来管理和控制进程所需的所有数据)</strong>,
是一个比较复杂的数据结构.</li>
</ul>
<p>线程是什么?</p>
<p>什么是进程挂起?</p>
<h2 id="内存管理">内存管理</h2>
<p>操作系统使用</p>
<ul>
<li><strong>虚拟内存</strong>(允许程序以逻辑方式访问存储器,
"以逻辑方式"的含义是不考虑物理内存可用的空间数量)</li>
<li><strong>文件系统</strong>(实现长期存储)</li>
</ul>
<p>来实现下面的功能:</p>
<ul>
<li>进程隔离</li>
<li>自动分配和管理</li>
<li>支持模块化程序设计</li>
<li>保护和访问呢控制</li>
<li>长期存储</li>
</ul>
<p>分页机制用来解决<strong>因进程大小不一致难以将进程紧密地压入内存</strong>的问题,
同时:</p>
<ul>
<li><p>提供了虚地址和物理地址之间的<strong>动态映射</strong></p></li>
<li><p>进程由若干固定大小的<strong>页</strong>组成</p></li>
<li><p>程序通过虚地址访存<strong>字</strong>,
虚地址由<strong>页号</strong>和<strong>页中的偏移量</strong>(类似在词典查阅单词的方式)组成</p></li>
</ul>
<h2 id="信息保护和安全">信息保护和安全</h2>
<p>四类典型安全问题:</p>
<ul>
<li>可用性: 保护系统不被中断</li>
<li>保密性: 保证用户不能读取未授权访问的数据</li>
<li>数据完整性: 保护数据不被未授权修改</li>
<li>认证: 设计用户的身份的正确认证和消息或数据的合法性</li>
</ul>
<h2 id="调度和资源管理">调度和资源管理</h2>
<p>任何资源分配和调度策略都必须考虑三个因素:</p>
<ul>
<li>公平性</li>
<li>有差别的响应性: 区分提供不同服务的部件</li>
<li>有效性:
获得<strong>最大吞吐量</strong>和<strong>最小响应时间</strong>;
在分时情形下, 可以容纳尽可能多的用户.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202309071056621.png" style="zoom: 50%;" /></p>
<h2 id="现代操作系统的特征">现代操作系统的特征</h2>
<p><span class="math inline">\(\it 1.\)</span> <strong>微内核</strong>:
只给内核分配一些最基本的功能, 包括<strong>地址空间</strong>,
<strong>进程间通信</strong>和<strong>基本的调度</strong>, 优点是</p>
<ul>
<li>简化了实现</li>
<li>提供了灵活性</li>
<li>适用于分布式环境.</li>
</ul>
<p><span class="math inline">\(\it 2.\)</span> <strong>多线程</strong>:
把执行一个应用程序的进程划分为可以同时在运行的多个线程.</p>
<blockquote>
<p>线程是什么? 线程和进程的区别是什么?</p>
</blockquote>
<p><span class="math inline">\(\it 3.\)</span>
<strong>对称多处理</strong>:</p>
<ul>
<li>多个进程和线程可以并行运行</li>
<li>多个处理器对用户来讲是透明的(共享内存和I/O并可执行同一任务)</li>
<li>操作系统在不同的处理器上调度不同的进程或线程,
并负责它们之间的同步</li>
</ul>
<p>优点:</p>
<ul>
<li>性能: 多个处理器可以在不同的处理器上同时运行</li>
<li>可用性: 单个处理器的失效不会导致机器停止</li>
<li>渐增性: 系统性能可以随着添加新的处理器而提高</li>
<li>扩展性: 生产商根据处理器的数量提供不同价格与性能的产品.</li>
</ul>
<p><span class="math inline">\(\it 4.\)</span> 分布式操作系统</p>
<p><span class="math inline">\(\it 5.\)</span> 面向对象的设计</p>
<h2 id="容错性">容错性</h2>
<p>容错性指系统或部件发生软硬件错误时, 能够继续正常运行的能力.
操作系统采用下面的技术提高容错性:</p>
<ul>
<li>进程隔离: 进程的内存, 文件存取和执行过程相互隔离</li>
<li>并发机制: 保证进程通信或协作时的正确性</li>
<li>虚拟机</li>
<li>检测点(一个 backup)和回滚机制 (退回检测点)
(和数据库的事务部分很像)</li>
</ul>
<h2
id="多处理器和多核操作系统设计考虑因素">多处理器和多核操作系统设计考虑因素</h2>
<p>什么八股文, 不想写了.</p>
<h1 id="进程-1">进程</h1>
<blockquote>
<p><strong>进程都有什么状态? 进程的这些状态是如何互相转换的?
产生这些转换的原因是什么? 操作系统管理控制进程都需要哪些信息?
</strong></p>
</blockquote>
<p>进程的两个基本元素:
<strong>程序代码</strong>与<strong>和代码相关的一组数据</strong>,
除此之外还有<strong>进程控制块(PCB)</strong>, 进程控制块:</p>
<ul>
<li>包含了进程的元素</li>
<li>可以中断和恢复进程的执行(好像中断从未发生过一样)</li>
<li>由操作系统创建和管理</li>
<li>是支持多进程的重要工具</li>
</ul>
<p>进程执行的任意时刻, 都可以 用 <strong>标识符, 状态, 优先级,
程序计数器, 内存指针, 上下文数据, I/O状态信息, 记账信息(处理器时间总和,
使用的时钟数总和, 时间限制, 记帐号等)</strong> 这些元素来表征,
这些元素存在 PCB 中.</p>
<p><strong>可以说 PCB 集合定义了操作系统的状态</strong>。</p>
<p>进程的基本特征:</p>
<ul>
<li>动态性: <strong>本质特征</strong></li>
<li>并发性</li>
<li>独立性: 各进程的地址空间相互独立,
<strong>除非采用进程间通信手段</strong></li>
<li>异步性: 按各自独立的不可预知的速度向前推进</li>
</ul>
<blockquote>
<p><strong>异步</strong>是什么意思?</p>
</blockquote>
<blockquote>
<p>进程和程序的区别是什么?</p>
<p>答: 进程=进程控制块+程序+相关数据. 进程动态而程序静态,
注意进程和程序之间不存在一一对应关系(一个应用程序可以对应多个进程的执行,
在 Windows 的任务管理器中可以看到例子).</p>
</blockquote>
<h2 id="进程状态">进程状态</h2>
<p>如何描述进程? 列出进程执行的指令序列, 可以描述单个进程的行为,
这样的指令序列被称为进程<strong>轨迹(trace)</strong>.</p>
<p>定义进程的轨迹后,
可以用<strong>多个进程执行的轨迹</strong>来描述处理器的行为,
分派器可以将处理器从一个进程切换到另一个进程.</p>
<h3 id="进程的两状态模型">进程的两状态模型</h3>
<p>进程有<strong>运行态</strong>和<strong>非运行态</strong>.</p>
<p>进程的创建和终止</p>
<h3 id="五状态模型">五状态模型</h3>
<p>将非运行态分为两个状态: 就绪态(ready)和阻塞态(blocked),
一共是五个状态:</p>
<ul>
<li>运行态</li>
<li>就绪态</li>
<li>阻塞态</li>
<li>新建态</li>
<li>退出态</li>
</ul>
<h2 id="进程描述">进程描述</h2>
<blockquote>
<p>这部分关注的信息是, 操作系统要控制并管理资源, 需要哪些信息?
用什么结构来控制和管理? 如果这个资源是<strong>进程</strong>,
信息具体是什么呢? 管理进程的具体结构是什么?</p>
</blockquote>
<p>进程的物理存在是:
<strong>进程的位置</strong>和<strong>进程的属性</strong>,
操作系统通过这两点管理和控制进程.</p>
<p><strong>PCB, Data, Stack, Code</strong> 的集合称为进程映像(process
image).</p>
<p>PCB 控制的元素包括:</p>
<ul>
<li><p><strong>进程标识信息</strong>,
典型的是<strong>标识符(ID)</strong>, 包括</p>
<ul>
<li>当前进程的PID</li>
<li>父进程的PID</li>
<li>用户ID</li>
</ul>
<p>用来对进程<strong>索引</strong>,
在做某些事的时候指明和区分每个进程.</p></li>
<li><p><strong>处理器状态信息</strong>, 主要是一些寄存器, 包括:</p>
<ul>
<li>用户可见寄存器(下面的两个寄存器用户不可见):
<strong>用户模式</strong>下机器语言可以访问的寄存器.</li>
<li>控制和状态寄存器, 就是 PSW, 需要参考计组中的内容.</li>
<li>栈指针: 栈保存参数和过程调用或系统调用的<strong>地址</strong>,
栈指针指向栈顶.</li>
</ul></li>
<li><p>进程控制信息:
操作系统控制和协调各种活动进程所需的额外信息.</p></li>
</ul>
<h2 id="进程控制">进程控制</h2>
<blockquote>
<p>这部分探讨的问题是,
操作系统是如何<strong>具体</strong>管理和控制进程的?
这包括进程的<strong>创建</strong>和<strong>切换</strong>, 是如何创建的?
因为什么发生了进程切换? 以及:</p>
<ul>
<li>进程创建时<strong>操作系统</strong>和<strong>进程</strong>会出现哪些变化?</li>
<li>进程切换时操作系统和进程会出现哪些变化?</li>
</ul>
</blockquote>
<p><strong>使用两种模式的原因是保护操作系统和重要的操作系统表(如PCB)不受用户程序的干扰.</strong></p>
<p>模式切换的原因是<strong>系统调用</strong>或者<strong>中断</strong>:</p>
<p>中断出现 <span class="math inline">\(\to\)</span>
PC置为中断处理程序的开始地址 <span class="math inline">\(\to\)</span>
user转为kernel, 以便中断处理<strong>能执行特权指令</strong>.</p>
<p>模式切换不一定导致进程切换, 比如 I/O 中断来了之后, 处理完 I/O
中断还会继续处理原进程. 还有 <code>getpid()</code>.</p>
<p>如果当前的进程状态变化(就绪或阻塞), 则回进程切换.</p>
<p><strong>进程切换的步骤:</strong></p>
<p><em>1.</em> 保存处理器<strong>上下文环境</strong>,
保存到<strong>PCB</strong>中.</p>
<p><em>2.</em> 更新当前处于运行状态的PCB.</p>
<p><em>3.</em> 将进程的PCB已知相应队列</p>
<p><em>4.</em> 选择另一个进程执行</p>
<p><em>5.</em>
更新PCB的信息(原来的进程信息改成切换成的新的进程的信息)</p>
<p><em>6.</em> 更新内存管理数据结构</p>
<p><em>7.</em> 恢复被选择进程的上下文环境</p>
<h2 id="unix-svr4">UNIX SVR4</h2>
<figure>
<img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202309141154715.png"
alt="UINX进程状态转换图" />
<figcaption aria-hidden="true">UINX进程状态转换图</figcaption>
</figure>
<p>用文字描述上图的状态转换.</p>
<h3 id="fork"><code>fork()</code></h3>
<p>一个进程使用系统调用 <code>fork</code> 来创建一个新的进程,
新的进程称为子进程, 其内存内容与调用它的进程(称为父进程)相同.
在父进程中, <code>fork</code> 返回子进程的PID, 在子进程中,
<code>fork</code> 返回零. 子进程会复制父进程的 image,
拥有<strong>一份独立的 copy</strong>.</p>
<p>调用 <code>fork()</code> 之后, 从 <code>fork</code> 所在的语句开始,
下面的所有语句将同时在父子进程中执行.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global = <span class="number">4</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span>  pid; </span><br><span class="line">    <span class="type">int</span> vari = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fork\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    global++;</span><br><span class="line">    vari--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global=%d,vari=%d\n&quot;</span>, global, vari);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码中, 即使 <code>global</code> 是全局变量, 但是子进程中对
<code>global</code> 的改变不会影响父进程中 <code>global</code> 的值.</p>
<h1 id="线程">线程</h1>
<h2 id="为什么有线程">为什么有线程</h2>
<p>由于进程的两个特点(资源所有权, 调度/执行)是相互独立的,
为了区分这两个特点:</p>
<ul>
<li>调度并分派的单位称为线程</li>
<li>拥有资源所有权的单位称为进程</li>
</ul>
<p><strong>多线程</strong>是指在操作系统在<strong>单个进程</strong>内支持<strong>多个并发执行路径</strong>的能力.</p>
<h2 id="线程的特征与优点">线程的特征与优点</h2>
<p>1: 线程与特征极为相似, 线程所具有的特征为:</p>
<ul>
<li>线程执行状态</li>
<li>未运行时保存的线程上下文, 是<strong>寄存器的环境</strong>,
保存为了便于下一次调用时恢复信息.</li>
<li>执行栈</li>
<li>静态存储空间, 以及与进程内其他线程共享的内存和资源的访问</li>
</ul>
<p>2: <strong>进程中所有的线程共享该进程的状态和资源.</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202309231429002.png"
alt="多线程进程模块中, 每个线程都有一个线程控制块TCB, 用户栈和内核栈, 在所有线程之外有一个进程控制块PCB." />
<figcaption aria-hidden="true">多线程进程模块中,
每个线程都有一个线程控制块TCB, 用户栈和内核栈,
在所有线程之外有一个进程控制块PCB.</figcaption>
</figure>
<p>3: 线程的优点是<strong>各方面</strong>的速度更快, 包括</p>
<ul>
<li>创建: 创建线程的时间更少.</li>
<li>终止: 终止线程的时间更少.</li>
<li>线程间切换: 花费时间小于进程间切换.</li>
<li>通信效率更高: 线程共享很多内存和文件,
<strong>无需调用内核</strong>就可以通信.</li>
</ul>
<p>4: 在支持线程的操作系统中,
调度和分派是<strong>在线程基础上</strong>完成:
<strong>挂起/终止</strong>进程会<strong>挂起/终止</strong>进程内所有的线程(<strong>因为所有线程共用一个地址空间</strong>).</p>
<p>5: 类似于进程, 线程的主要状态为 <strong>运行/就绪/阻塞</strong>,
与线程状态相关的基本操作为
<strong>派生/阻塞/解除阻塞/结束</strong>(这些都是动词, 宾语为线程):</p>
<ul>
<li>派生类似于 fork, 新创建的进程可以派生出一个线程,
进程内部的线程也可以派生出另一个线程.</li>
<li>解除阻塞会将被阻塞的线程移入就绪队列中.</li>
</ul>
<p>6: <strong>线程同步</strong>指的是, 一个进程内的线程:</p>
<ul>
<li>共用地址空间和资源</li>
<li>一个线程对共享资源的修改都会影响到其他线程</li>
</ul>
<h2 id="线程分类">线程分类</h2>
<p>1: 用户级线程 (ULT) 优点:</p>
<ul>
<li>线程切换不需要内核模式的特权, 节省了两次状态转换的开销</li>
<li>调度策略因应用程序不同而不同, 可以量身定做调度算法</li>
<li>可以运行在任何操作系统上</li>
</ul>
<p>缺点:</p>
<ul>
<li>执行系统调用时不仅会阻塞这个线程, 也会阻塞这个线程中的所有进程.
将应用程序写成一个多进程程序而非多线程程序可以解决这个缺点.</li>
<li>不能使用多处理器技术. 使用 jacketing 技术,
<strong>把一个产生阻塞的系统调用转化为一个非阻塞的系统调用</strong>,
可以解决这个缺点.</li>
</ul>
<p>2: 内核级线程 (KLT) 中, 应用程序没有线程管理的工作.</p>
<p>优点:</p>
<ul>
<li>内核可以把同一个进程内的多个线程调度到多处理器上</li>
<li>当一个线程阻塞时, 内核可以调度同一进程内的其他线程</li>
<li>内核例程本身也可以是多线程的</li>
</ul>
<p>缺点: 将控制权从一个线程切换到另一个线程时, 需要切换到内核模式.</p>
<p>可以用混合方法.</p>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202309231524680.jpg" /></p>
<h1 id="单处理器调度">单处理器调度</h1>
<p>1: 调度就是把进程分配到处理器上执行的方式,
一个好的调度算法要满足响应时间快, 吞吐量大, 处理器效率高.</p>
<p>2: 调度的类型包括长程调度, 中程调度, 短程调度,
它们在计算机中有对应的程序, 这些程序的作用分别是:</p>
<ul>
<li>长程调度程序决定<strong>哪个程序可以进入系统中处理</strong>,
控制系统的并发度(指有多少进程在等待处理器).
就是用来将刚创建好的进程调度到就绪队列中.</li>
<li>中程调度程序实现了一部分的<strong>交换功能</strong>(即进程的换入换出),
在挂起状态与非挂起状态之间执行.</li>
<li>短程调度程序精确地决定<strong>下次执行哪个进程</strong>.</li>
</ul>
<p>可以看出短程调度执行得最为频繁,
当导致<strong>当前进程阻塞</strong>或被抢占的事件发生时就需要调用短程调度程序.</p>
<p>3: 与调度规则相关的概念:</p>
<ul>
<li>响应时间: 用户提交一个<strong>请求</strong>开始,
到<strong>接收进程的响应</strong>之间的时间间隔, 等于 <span
class="math inline">\(输入传送时间+处理时间+响应传送时间\)</span>.</li>
<li>周转时间: 又称驻留时间,
一个进程从<strong>提交到完成</strong>之间的时间间隔.
周转时间包括等待调度(包括在外存和内存等待), 等待资源和阻塞的时间,
往往包括响应时间, 因为进程完成之前用户可能会多次请求,
进程会多次响应.</li>
<li>截止时间: 某任务<strong>最迟开始的时间</strong>,
或者必须完成的最迟时间, 这两个定义是等价的.</li>
<li>吞吐量: 单位时间内系统完成的进程数.</li>
<li>处理器利用率: 处理器处于忙状态的时间与总的时间的比值.</li>
</ul>
<p>在周转时间的基础上, 可以定义<strong>带权周转时间</strong> <span
class="math inline">\(W_i=T_i/T_{si}\)</span>, 其中 <span
class="math inline">\(T_i\)</span> 表示进程 <span
class="math inline">\(i\)</span> 的周转时间, <span
class="math inline">\(T_{si}\)</span> 表示系统为进程 <span
class="math inline">\(i\)</span> 提供的服务时间(或者说占用处理器的时间),
显然往往有 <span class="math inline">\(T_i\ge T_{si},W_i\ge
1\)</span>.</p>
<p>在所有系统中, 面向用户的规则都非常重要, 而在单用户系统中,
面向系统的重要性就要低一些.</p>
<p>4: 调度的决策模式包括</p>
<ul>
<li>抢占: 在进程执行过程中被操作系统中断并转换为就绪状态.
可能导致抢占的原因: 1) 更高优先级的进程处于就绪状态; 2)
中断发生后唤醒一个进程; 3)周期性的时间中断;</li>
<li>非抢占: 只有当执行完毕或者因I/O等被阻塞时才会释放处理器.
(即进程主动放弃处理器)</li>
</ul>
<p>5: 调度的选择函数: 可以理解为进程的优先级的计算方式. 设 <span
class="math inline">\(w\)</span>
表示目前为止进程在系统里的<strong>等待时间</strong>, <span
class="math inline">\(e\)</span> 表示目前为止花费的执行时间, <span
class="math inline">\(s\)</span> 表示进程所需的总服务时间,
这个数据需要基于历史数据估计或者用户提供.</p>
<h2 id="重要的调度算法">重要的调度算法</h2>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202310061533602.png" /></p>
<blockquote>
<p>进程的<strong>饥饿</strong>指的是进程长时间得不到执行或者是执行速度非常缓慢导致长时间无法执行完毕.</p>
<p><em>SRT</em>
的<strong>到达时抢占</strong>是指在任意时刻<strong>处于运行状态的都是剩余时间最短的进程</strong>，如果进程
<em>A</em> 运行的过程中某个时刻进程 <em>B</em>
的剩余时间成为最短的，那么 <em>B</em> 就会抢占 <em>A</em>.</p>
</blockquote>
<h3 id="fcfs">FCFS</h3>
<p>调度规则, 调度的决策模式, 调度算法, 实时系统和实时调度</p>
<p>需要学会画 round-robin 的调度图, 搞清楚进程在队列之间的切换就好.</p>
<p>各种调度的特点：</p>
<ul>
<li>选择函数</li>
<li>决策模式: 包括 <strong>抢占</strong> (又称为<strong>剥夺</strong>)
和 <strong>非抢占</strong> (进程仅在主动放弃时才会中断)</li>
<li>吞吐量</li>
<li>响应时间</li>
<li>开销</li>
<li>对进程影响: 区分对短进程, 长进程和I/O密集型进程的有利与不利</li>
<li>饥饿: 无饥饿指的是在就绪队列中的进程<strong>总是</strong>能得到调度,
不论等待时间多久</li>
</ul>
<h1 id="实时系统与实时调度">实时系统与实时调度</h1>
<p>1: 实时任务分类</p>
<p>2: 实时操作系统特点</p>
<ul>
<li>可确定性</li>
<li>可响应性</li>
<li>用户控制</li>
<li>可靠性</li>
<li>失效弱化</li>
</ul>
<p>3: 实时调度:</p>
<ul>
<li>调度方法: 下次允许调度哪个任务</li>
<li>抢占方式</li>
</ul>
<p>4: 实时调度的调度方法</p>
<ul>
<li>静态表驱动调度法: 按照任务周期到达的时间, 执行时间,
完成截止时间以及任务的优先级指定调度表. 比如动车各个时刻是固定的,
可以指定车站中动车的发车时间. 缺陷:
任意一个调度改动后都会影响调度表的修改. 比如动车某一辆除了问题,
那么与之相关的所有的动车的发车时刻都会受到影响.</li>
<li>静态优先级抢占调度法: 实时系统中一般根据任务的时间约束赋予优先级,
比如RM算法.</li>
</ul>
<h1 id="并发">并发</h1>
<p>并发指的是系统在<strong>同一段时间</strong>内可以执行多个作业,
定义比并行要弱一些.</p>
<p>在单处理器多道程序系统中, 虽然在任意时刻只能有一个进程占用处理器,
但是由于时间片机制的存在, 在一段时间内,
从外部看来好像是多个进程一起执行,
因此可以认为单处理器多道程序系统中也存在并发.</p>
<h2 id="并发的原理">并发的原理</h2>
<blockquote>
<p>并发的原理部分主要介绍单处理器多道程序系统是如何在交替执行进程的同时保证不发生<strong>错误</strong>,
这些错误可能包括:</p>
<ul>
<li>死锁</li>
<li>饥饿</li>
<li>忙等</li>
<li>同时访问或修改共享资源</li>
</ul>
<p>这一部分很像数据库中事务的执行, 要保证事务的ACID特性,
进程同样有类似的特性.</p>
<p>原子性, 一致性(), 隔离性(互斥), 持久性.</p>
</blockquote>
<p>1: 如果需要保护共享的全局变量, 唯一的方法是控制访问该变量的代码.</p>
<p>2: 进程间的关系包括:</p>
<ul>
<li>竞争</li>
<li>通过共享合作(共享不当可能导致输出错误)</li>
<li>通过通信合作(通信顺序不当可能导致沉默)</li>
</ul>
<p>进程之间的感知程度都有哪些? 对应的进程关系是什么? 在该关系下,
可能会存在哪些问题?</p>
<h1 id="互斥">互斥</h1>
<p>互斥的要求(即访问临界区的原则):</p>
<ul>
<li>空闲让进: 临界区空就进.</li>
<li>忙则等待: 任意时刻只允许一个进程在临界区/临界区不空就等.</li>
<li>有限等待: 进程不能饥饿/死锁, 在有限时间内能进入临界区.</li>
<li>让权等待: 在临界区里不能呆的时间太长(不能占着茅坑不拉屎).</li>
</ul>
<h2 id="软件方法">软件方法</h2>
<p>爱斯基摩人的小屋只能容纳一人, 当小屋有人时, 在门口竖旗表示有人.
(用厕所好像也能举例子).</p>
<p>Dekker 算法和 Peterson 算法.</p>
<h2 id="硬件方法">硬件方法</h2>
<p>硬件方法：</p>
<ul>
<li>中断禁用: 为保证互斥, 只需要保证进程在执行时不被中断即可.</li>
<li>机器指令
<ul>
<li>compare &amp; swap</li>
<li>exchange</li>
</ul></li>
</ul>
<p>中断禁用不能用在多处理器中, 而且代价比较高,
会导致程序效率大幅度下降.</p>
<h1 id="信号量实现同步与互斥">信号量实现同步与互斥</h1>
<p>1: 信号量值的含义:</p>
<ul>
<li>信号量初始化为当前的可用资源数</li>
<li></li>
</ul>
<p>信号量小于零时, 它的绝对值表示被阻塞的进程个数.</p>
<h2
id="用信号量解决互斥-同步问题的一般步骤">用信号量解决互斥-同步问题的一般步骤</h2>
<ol type="1">
<li>确定所有的信号量</li>
</ol>
<h2 id="生产者消费者问题">生产者/消费者问题</h2>
<p>描述:</p>
<ul>
<li>生产者产生数据</li>
<li>消费者消耗数据</li>
</ul>
<p>生产者需要的资源为缓冲区剩余空间个数,
消费者需要的资源为缓冲区的数据个数.</p>
<p>保证:</p>
<ul>
<li>生产者-生产者, 消费者-消费者, 生产者-消费者互斥地访问缓冲</li>
<li>满不生产, 空不消费.</li>
</ul>
<p>注意:</p>
<ul>
<li>先申请资源信号量, 再申请互斥信号量.
否则可能会<strong>发生死锁</strong>.</li>
</ul>
<h3 id="缓冲区的空间数为-nnge-2">缓冲区的空间数为 <span
class="math inline">\(n(n\ge 2)\)</span></h3>
<p>当缓冲区的空间数不小于 2 时, 除了使用缓冲区的互斥信号量外,
还需要两个资源信号量(空间资源信号量和数据资源信号量).</p>
<h3 id="缓冲区的空间数为-1">缓冲区的空间数为 1</h3>
<p>当缓冲区的空间数仅为 1 时, 只用一个缓冲区的互斥信号量是不够的,
因为这样可能会发生死锁</p>
<h1 id="死锁">死锁</h1>
<p>1: 死锁是一组相互竞争系统资源或进行通信的进程间的永久阻塞.</p>
<p>2: 一种引发死锁的原因是资源的竞争, 首先对资源分类:</p>
<ul>
<li><p>可重用资源. 一次仅供一个进程安全使用且不因使用而耗尽的资源.</p>
<blockquote>
<p>比如处理器, 内存和外存, I/O通道等.</p>
</blockquote></li>
<li><p>可消耗资源. 可被创建(生产)和销毁(消耗)的资源,
且消费进程得到可消耗资源后, 该资源就不再存在.</p>
<blockquote>
<p>如中断, 信号, 消息, 以及I/O缓冲区中的信息.</p>
<p>对于进行通信的进程, 当双方都等对方先发消息而不主动发消息,
就会导致沉默, 是一种死锁.</p>
</blockquote></li>
</ul>
<p>3: 死锁的必要条件：</p>
<ul>
<li>互斥.</li>
<li>占有且等待. 一个进程等待其他进程时, 继续占有已分配的资源.</li>
<li>不可抢占.</li>
</ul>
<p>充分条件：</p>
<ul>
<li>循环等待. 在资源分配图中存在一个闭合的进程链,
使得每个进程至少占有下一个进程所需的一个资源.</li>
</ul>
<p>4: 通过资源分配图可以判断是否存在死锁,
称为<strong>资源分配图的化简</strong>. 对于一个资源分配图,
找到全部请求都能满足的进程,
删去该进程的分配边和请求边(进程的request和资源的held by), 重复执行,
只扫不能化简. 若存在非孤立点, 则存在死锁.</p>
<h2 id="解决死锁">解决死锁</h2>
<p>通过防止充分条件或必要条件的发生来阻止死锁的发生.</p>
<p>必要条件的<strong>互斥</strong>不能禁止,
禁止互斥可能会引发错误(如同时写).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">死锁预防</th>
<th style="text-align: center;">死锁避免</th>
<th style="text-align: center;">死锁检测</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="死锁预防">死锁预防</h3>
<ol type="1">
<li><p>防止占有且等待: 要求进程一次性地申请所有需要的资源,
当要求无法满足时, 就阻塞该进程, 知道能申请到所有需要的资源.</p></li>
<li><p>防止不可抢占. 若一个占有某些资源的进程在申请其他资源的时候被拒绝,
则</p>
<ul>
<li>释放最初占有的资源</li>
<li>要求另一个进程释放资源</li>
</ul></li>
<li><p>防止循环等待. 给资源定义优先级,
即定义一个请求资源的顺序.</p></li>
</ol>
<h3 id="死锁避免">死锁避免</h3>
<p>允许三个必要条件, 并动态地进行检查是否会导致死锁.
<strong>需要预知资源的请求.</strong></p>
<p>定义 <span
class="math inline">\(A=(A_{ij})(\mathrm{Allocation}),V=(V_j)(\mathrm{Available})\)</span>,
<span class="math inline">\(C=C_{ij}(\mathrm{Claim})\)</span>, <span
class="math inline">\(R=(R_j)(\mathrm{Resource})\)</span> .</p>
<ol type="1">
<li>进程启动拒绝. 若有一个进程请求会导致死锁, 则不启动该进程.</li>
<li>资源分配拒绝. <strong>银行家算法</strong>: 搜索安全序列.</li>
</ol>
<h3 id="死锁检测">死锁检测</h3>
<p>死锁检测算法.</p>
<p>定义 <span class="math inline">\(Q=(Q_{ij})\)</span> 为当前进程 <span
class="math inline">\(i\)</span> 对<span
class="math inline">\(j\)</span> 类资源的请求数. 算法流程如下:</p>
<ol type="1">
<li>标记 <span class="math inline">\(A\)</span> 中全为 <span
class="math inline">\(0\)</span> 的行 <span
class="math inline">\(i\)</span>.</li>
<li>令临时变量 <span class="math inline">\(W=V\)</span>.</li>
<li>寻找进程 <span class="math inline">\(i\)</span> 满足 <span
class="math inline">\(Q_{ij}\le W_j,1\le j\le m\)</span>
(<strong>即寻找是否存在可分配资源的进程</strong>).</li>
<li>若能找到满足 3 中的进程 <span class="math inline">\(i\)</span>,
则标记进程 <span class="math inline">\(i\)</span>, 并令 <span
class="math inline">\(W_j:=W_j+A_{ij}\)</span>
(<strong>找到可以分配资源的进程, 分配后等该进程执行完毕,
将已分配的资源释放掉</strong>), 并转到 3.</li>
<li>若找不到满足 3 中的进程 <span class="math inline">\(i\)</span>,
终止算法.</li>
</ol>
<h4 id="死锁解除">死锁解除</h4>
<p>检测到死锁后, 有下面的解决方法:</p>
<ol type="1">
<li>撤销进程.
<strong>撤销所有死锁进程</strong>或<strong>连续撤销死锁进程直到不发生死锁</strong>.</li>
<li>回退. 将进程回退到前面定义的某些检查点, 并重新启动所有进程.</li>
<li>抢占. 连续抢占进程直到不存在死锁.</li>
</ol>
<blockquote>
<p>优先对哪些死锁的进程执行上述方案?</p>
<ul>
<li>消耗处理器时间少</li>
<li>输出少</li>
<li>分配资源少</li>
<li>剩余执行时间长</li>
<li>优先级最低</li>
</ul>
<p>等等.</p>
</blockquote>
<h2 id="哲学家就餐问题">哲学家就餐问题</h2>
<h1 id="内存管理-1">内存管理</h1>
<p>程序存储在外存或 cache 中,
内存管理的主要操作是<strong>处理器把程序装入到内存中执行</strong>,
因此不同程序(进程)在内存中的组织和分配方式是首先要考虑的,
最朴素的方法是将内存划分为若干区域, 每次给要装入到内存的程序分配一整块,
根据块的特点有:</p>
<ul>
<li><p><strong>固定分区</strong>: 将内存划分为大小固定的块
(因此数量确定),
这些块<strong>大小相等</strong>或<strong>大小不等</strong>.</p>
<ul>
<li>所有分区都满且<strong>没有进程处于就绪态或运行态</strong>: OS
换出一整个进程的所有分区, 再装入另一个进程.</li>
<li>程序太大超过最大分区的大小: 使用覆盖技术设计程序,
使得程序只有一部分在内存中.</li>
<li>程序太小: 也要占据一个完整的分区,
导致<strong>内部碎片</strong>的产生.
内部碎片是分区内部并未装入数据块的部分.</li>
<li>分区大小不等时可缓解这两个问题,
但是装入进程时装入不同大小的块的策略对性能的影响也是不同的,</li>
</ul></li>
<li><p><strong>动态分区</strong>:</p>
<ul>
<li><p>外部碎片: 在分区外的存储空间变成了越来越多的碎片.</p></li>
<li><p>放置算法: 对于要装入内存的程序</p>
<ol type="1">
<li>最佳适配: 选择大小最接近的块</li>
<li>首次适配: 从头扫描内存, 选择大小足够的第一个块.</li>
<li>下次适配: 从上一次放置的位置开始扫描, 选择大小足够的第一个块.</li>
</ol>
<p>性能: <span
class="math inline">\(首次适配&gt;下次适配&gt;最佳适配\)</span>.</p></li>
</ul></li>
<li><p>Buddy System. 一种二分的策略. 整个内存大小为 <span
class="math inline">\(2^U\)</span> Byte. 如果来的块的大小为 $k$</p></li>
</ul>
<h2 id="基本分页和分段">基本分页和分段</h2>
<p>基本分页方式中, 页框大小等于页号</p>
<ul>
<li>逻辑地址为 <span class="math inline">\((页号,偏移量)\)</span></li>
<li>物理地址为 <span class="math inline">\((页框号,偏移量)\)</span></li>
<li>页表是页框号到页号的映射, 可以通过页号找到页框号</li>
</ul>
<blockquote>
<p>这类似于字典, 每一页白纸可以看作是页框,
某个单词的<strong>实际页数+行数</strong>可以视作其物理地址. 以 <span
class="math inline">\(C\)</span> 开头的单词是中间的若干页, 某个以 <span
class="math inline">\(C\)</span>
为开头单词的逻辑地址为<strong>该单词相对于第一页以 <span
class="math inline">\(C\)</span> 为开头的单词的页数+行数.</strong>
比如逻辑地址为 <span class="math inline">\((50,2)\)</span> 的单词,
页表中有 <span
class="math inline">\((\mathrm{Page,Page~Frame})=[50,150]\)</span>,
那么物理地址为 <span class="math inline">\((150,2)\)</span>.</p>
</blockquote>
<p>设内存为 <span class="math inline">\(2^{U}\)</span> 字节,
分页且页框(或者页)大小为 <span class="math inline">\(2^P\)</span> 字节,
则偏移量为逻辑地址的后 <span class="math inline">\(P\)</span> 位,
内存中一共有 <span class="math inline">\(2^{U-P}\)</span> 个页框,
页框号为逻辑地址的前 <span class="math inline">\(U-P\)</span> 位.
页表是页框号到页号的映射, 通过页表和页框号获取页号, 与 <span
class="math inline">\(P\)</span> 位偏移量进行拼接得到物理地址.
对于十进制数, 需要通过取整和取余来获取页号和偏移量的十进制表示.</p>
<h2 id="虚拟内存">虚拟内存</h2>
<h1 id="文件系统">文件系统</h1>
<h2 id="unix-文件管理">UNIX 文件管理</h2>
<blockquote>
<p>掌握：</p>
<ul>
<li><p>UNIX 文件类型</p></li>
<li><p>索引节点 Inode 的结构</p></li>
<li><p>混合索引方式相关计算</p></li>
<li><p>UNIX 路径解析</p></li>
</ul>
</blockquote>
<h3 id="索引结点结构">索引结点结构</h3>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202312221654703.png" /></p>
<h3 id="文件分配">文件分配</h3>
<p>FreeBSD 系统最小的块大小为 4KB 时, 块地址项长度为 8B,
则每一块可以存放 <span class="math inline">\(\mathrm{4K/8}=512\)</span>
个块地址项.</p>
<ul>
<li>直接块有 12 个, 总容量为 <span class="math inline">\(12\times
4\mathrm{KB}=48\mathrm{KB}\)</span>.</li>
<li>一级间接块有 1 个, 块中有 512 个块地址项, 指向 512 个块, 总容量为
<span class="math inline">\(512\times
4\mathrm{KB}=2\mathrm{MB}\)</span>.</li>
<li>二级间接块有 1 个, 一共有 <span
class="math inline">\(512^2=256\mathrm{K}\)</span> 个块, 总容量为 <span
class="math inline">\(256\mathrm{K}\times
4\mathrm{KB}=1\mathrm{GB}\)</span>.</li>
<li>三级间接块有 1 个, 一共有 <span
class="math inline">\(512^3=128\mathrm{M}\)</span> 个块, 总容量为 <span
class="math inline">\(\mathrm{128M\times 4KB=512GB}\)</span>.</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202312221622289.png" /></p>
<blockquote>
<p>每个块可存 <span class="math inline">\(256/4=64\)</span> 个地址项, 则
<span class="math display">\[
\begin{aligned}
4\times 直接+2\times 一级+二级
&amp;=4\times 256+2\times 64\times 256+64^2\times 256\\
&amp;=2^8\times (2^2+2^7+2^{12})\mathrm{B}\\
&amp;=(1+32+1024)\mathrm{KB}=1057\mathrm{KB}
\end{aligned}
\]</span></p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202312221627983.png" /></p>
<blockquote>
<p>给定字节偏移量 <span class="math inline">\(L\)</span> 求物理地址,
设块的大小为 <span class="math inline">\(B\)</span>.</p>
<ol type="1">
<li>首先计算其所在逻辑块号为 <span class="math inline">\(N=\lfloor
L/B\rfloor\)</span>, 以及块内偏移量为 <span class="math inline">\(L\bmod
B\)</span>.</li>
<li>根据 <span class="math inline">\(N\)</span>
的大小判断该逻辑块为直接块/一级/二级/三级, 对 <span
class="math inline">\(N\)</span> 进行拆分.</li>
</ol>
<p>对于 350000, 计算其所在的块数(逻辑块号)为 <span
class="math inline">\(341\)</span>, 且 <span
class="math inline">\(\mathrm{1KB/4B}=256\)</span>, <span
class="math inline">\(341&gt;10+256\)</span>, 且 <span
class="math inline">\(341=10+256+75\)</span>, 则在二级间接块的第 0
个一次间接块的第 75 个表项中, 其中的盘块号为 333, 则物理地址为盘块号 333
中的第 816 字节.</p>
</blockquote>
<h1 id="作业1">作业1</h1>
<p>1.归纳整理操作系统的基本功能。</p>
<blockquote>
<p>作为资源管理器, 包括内存的分配管理, I/O的访问控制, 对文件的访问控制,
对处理器的分配.</p>
</blockquote>
<p>2.论述批处理、分时和实时三种操作系统的<strong>基本特征</strong>。</p>
<blockquote>
<p>批处理: 有监控程序, 对一批程序进行自动处理,
分为简单批处理和多道批处理</p>
<ul>
<li>简单批处理: 处理器必须等待I/O指令完成才能继续处理,
处理器经常处于空闲状态</li>
<li>多道批处理: 多道性, 调度性, 无序性, 无交互能力</li>
</ul>
<p>分时: 多路性, 独立性, 及时性, 交互性</p>
<p>实时: 可确定性, 可响应性, 用户控制, 可靠性, 故障弱化能力</p>
</blockquote>
<p>3.为什么会有进程？分析理解进程的概念、上下文的含义。</p>
<blockquote>
<p>进程存在的原因是, 系统中在同一时间会有许多作业在运行,
为了防止不正确的同步/失败的互斥/不正确的程序操作/死锁等情况的发生,
需要设计系统级的机制来监控各个作业的运行.</p>
</blockquote>
<p>4.论述现代操作系统的特征。</p>
<p>5.解释单体内核和微内核的区别。</p>
<p>6.进程调度程序、时钟中断处理程序和命令解释程序在哪种模式下执行？</p>
<blockquote>
<p>进程调度程序和时钟中断程序: 内核模式</p>
<p>命令解释程序: 用户模式 (比如shell中的命令)</p>
</blockquote>
<p>7.分析系统调用时的模式切换过程？</p>
<h1 id="作业2">作业2</h1>
<blockquote>
<p>需要注意题目前的<strong>论述</strong>二字, 一定要详细说明.</p>
</blockquote>
<p>1.论述程序、进程、线程的区别与联系</p>
<p>2.论述进程控制块(PCB)的作用、存储内容</p>
<p>3.论述进程的基本特征。</p>
<p>4.以图为例，分析五状态进程模型</p>
<p>5.为什么引入挂起状态，其与阻塞状态的本质区别是什么？</p>
<p>6.论述进程切换与模式切换的区别。什么情况下会发生进程切换，什么情况下会发生模式切换。</p>
<p>7.什么是中断？中断的处理过程如何？</p>
<p>8.什么是系统调用？</p>
<p>9.比较不同类型线程的优缺点。</p>
<p>10.说明fork()函数的作用，并举例说明。</p>
<blockquote>
<p>可能会考的其他问题：</p>
<ol type="1">
<li><p>进程的轨迹是什么？
如何描述处理器的行为？分派器的作用是什么？</p></li>
<li><p>进程可以由什么内容来表征？这些内容存在PCB的哪一部分？</p></li>
<li><p>进程实体/进程映像是什么？包含哪些典型元素？</p></li>
<li><p>进程都有哪些状态？每个状态代表着什么含义？这些状态是如何相互转换的（或者说什么事件会触发这些状态之间的转换）？</p></li>
<li><p>操作系统可能因为哪些原因创建进程？操作系统创建进程的具体过程的步骤是什么？创建进程时若资源不足会发生什么？</p></li>
<li><p>进程可能因为哪些原因或事件而终止？操作系统终止进程的过程是什么？</p></li>
<li><p>进程在什么条件下会被阻塞？进程的阻塞和唤醒的具体过程是什么？</p></li>
<li><p>分析进程的七状态模型。</p></li>
<li><p>进程可能因为哪些原因被挂起？挂起的进程有哪些特点？挂起进程所需的代理的作用是什么？</p></li>
<li><p>操作系统的控制结构的作用是什么？操作系统都有哪些控制结构？</p></li>
<li><p>操作系统在管理和控制进程时必须知道进程的位置和进程的属性，这被称为<strong>进程的物理存在</strong>，进程的物理存在具体包含哪些内容？</p></li>
<li><p>为什么要使用用户模式和控制模式两种模式？</p>
<p>保护操作系统和重要的操作系统表（比如PCB）不受用户程序的干扰。</p></li>
<li><p>叙述进程切换的步骤。</p></li>
<li><p>为什么要引入线程？叙述线程的优点。</p></li>
<li><p>叙述用户级线程、内核级线程以及混合方法的内容。</p></li>
</ol>
</blockquote>
<h1 id="作业3">作业3</h1>
<p>1.周转时间和响应时间有什么区别？</p>
<p>2.高响应比优先调度算法的主要优点是什么？</p>
<p>3.为什么说多级反馈队列调度算法能较好地各种用户需求？</p>
<p>4.进程A、B、C、D和E到达时间、服务时间如下表所示，试计算分别采用FCFS、RR(q=1)、RR(<span
class="math inline">\(q=4\)</span>)、SPN、SRT、HRRN、FB(<span
class="math inline">\(q=1\)</span>)、FB(<span
class="math inline">\(q=2^i\)</span>)调度算法时，进程A、B、C、D和E的周转时间、带权周转时间，以及平均周转时间、平均带权周转时间，并对结果进行简要分析。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>进程</strong></th>
<th style="text-align: center;"><strong>到达时间</strong></th>
<th style="text-align: center;"><strong>服务时间</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">E</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<h1 id="作业4">作业4</h1>
<blockquote>
<p>信号量部分伪代码规范:</p>
<ul>
<li>信号量用 <code>semaphore</code> 声明, 读者写者问题中的
<code>conut</code> 就用 <code>int</code> 声明即可.</li>
<li>所有进程的函数返回值类型都为 <code>void</code>.</li>
<li>记得加分号.</li>
<li>主函数按照下面的写法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">parbegin</span>(p1,p2,p3); <span class="comment">// 所有同时执行的进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>1： 什么是临界资源、临界区，临界区的使用原则有哪些？</p>
<p>2： 简述信号量的含义及作用。</p>
<p>3： 请用P、V操作描述下列过程</p>
<p>4：
图书馆有N个座位，一张登记表，要求(1)阅读者进入时登记，取得座位号；(2)出来时注销。请用P、V操作描述一个读者的使用过程。</p>
<p>5： 4个并发执行的进程P1、P2、P3和P4合作解决数据计算问题：<span
class="math inline">\(Y_i=X_i^2+X_i^3\)</span>.</p>
<p>(1)P1不断产生随机数并放入的缓冲区A中；</p>
<p>(2)P2、P3分别读取缓冲区A中的数据并计算其平方值、立方值，然后分别放入缓冲区B、C中；</p>
<p>(3)P4读取缓冲区B、C中的数据，将其相加，并输出；</p>
<p>(4)缓冲区A、B、C的容量为1。</p>
<p>用P，V操作实现其同步过程。</p>
<p>下面的代码是错误的, 因为要求 P2, P3 取的是同一个数, 而下面 P2 和 P3
取的不是同一个数:</p>
<p><strong><em>Wrong Answer</em></strong> <code>pA</code>,
<code>pB</code>, <code>pC</code>
分别表示生产者对三个缓冲区使用(存数)的信号量, <code>cA</code>,
<code>cB</code>, <code>cC</code>
分别表示消费者对三个缓冲区使用(取数)的信号量. 伪代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pA=<span class="number">1</span></span><br><span class="line">pB=<span class="number">1</span></span><br><span class="line">pC=<span class="number">1</span></span><br><span class="line">cA=<span class="number">0</span></span><br><span class="line">cB=<span class="number">0</span></span><br><span class="line">cC=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">p1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(pA);</span><br><span class="line">        <span class="comment">// Produce a number randomly and put it in buffer A.</span></span><br><span class="line">        <span class="built_in">V</span>(cA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">p2</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(cA);</span><br><span class="line">        <span class="built_in">P</span>(pB);</span><br><span class="line">        <span class="comment">// Get the number in buffer A and calculate its square, and put it in buffer B</span></span><br><span class="line">        <span class="built_in">V</span>(cB);</span><br><span class="line">        <span class="built_in">V</span>(pA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">p3</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(cA);</span><br><span class="line">        <span class="built_in">P</span>(pC);</span><br><span class="line">        <span class="comment">// Get the number in buffer A and calculate its cube, and put it in buffer C</span></span><br><span class="line">        <span class="built_in">V</span>(cC);</span><br><span class="line">        <span class="built_in">V</span>(pA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">p4</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(cB)</span><br><span class="line">        <span class="built_in">p</span>(cC)</span><br><span class="line">        <span class="comment">// Get two numbers from buffer B and C respectively, and get the sum of them</span></span><br><span class="line">        <span class="built_in">V</span>(pC)</span><br><span class="line">        <span class="built_in">V</span>(pB)</span><br><span class="line">        <span class="comment">// output final result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>Correct Answer</em></strong></p>
<p>P1 需要等 P2 和 P3 都取数后才能再生产数, <strong>注意没有要求 P2, P3
对 A 互斥访问.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">gotA_2 = <span class="number">1</span>; <span class="comment">// 表示P2是否从A中取过数</span></span><br><span class="line">gotA_3 = <span class="number">1</span>; <span class="comment">// 表示P3是否从A中取过数</span></span><br><span class="line">getA_2 = <span class="number">0</span>; <span class="comment">// 表示P2是否可以从A中取数</span></span><br><span class="line">getA_3 = <span class="number">0</span>; <span class="comment">// 表示P3是否可以从A中取数</span></span><br><span class="line"></span><br><span class="line">full_B = <span class="number">0</span>; <span class="comment">// 缓冲区B是否满</span></span><br><span class="line">full_C = <span class="number">0</span>; <span class="comment">// 缓冲区C是否满</span></span><br><span class="line">empty_B = <span class="number">1</span>; <span class="comment">// 缓冲区B是否空</span></span><br><span class="line">empty_C = <span class="number">1</span>; <span class="comment">// 缓冲区C是否空</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">P1</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(gotA_2);</span><br><span class="line">        <span class="built_in">P</span>(gotA_3);</span><br><span class="line">        <span class="comment">// 产生数放到A中</span></span><br><span class="line">        <span class="built_in">V</span>(getA_2);</span><br><span class="line">        <span class="built_in">V</span>(getA_3); <span class="comment">// 通知P2,P3可以取数了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(getA_2);</span><br><span class="line">        <span class="comment">// 取数</span></span><br><span class="line">        <span class="built_in">P</span>(empty_B);</span><br><span class="line">        <span class="comment">// 算平方放进B</span></span><br><span class="line">        <span class="built_in">V</span>(gotA_2);</span><br><span class="line">        <span class="built_in">V</span>(full_B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P3</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(getA_3);</span><br><span class="line">        <span class="comment">// 取数</span></span><br><span class="line">        <span class="built_in">P</span>(empty_C); <span class="comment">// buffer C 空才能放数</span></span><br><span class="line">        <span class="comment">// 算立方放进 C</span></span><br><span class="line">        <span class="built_in">V</span>(gotA_3);</span><br><span class="line">        <span class="built_in">V</span>(full_C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P4</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">P</span>(full_B);</span><br><span class="line">        <span class="comment">// 取数</span></span><br><span class="line">        <span class="built_in">V</span>(empty_B);</span><br><span class="line">        <span class="built_in">P</span>(full_C);</span><br><span class="line">        <span class="comment">// 取数</span></span><br><span class="line">        <span class="built_in">V</span>(empty_C);</span><br><span class="line">        <span class="comment">// 计算输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin&#123;P1,P2,P3,P4&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 P4 不要写成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">P</span>(full_B);</span><br><span class="line"><span class="built_in">P</span>(full_C);</span><br><span class="line"><span class="built_in">V</span>(empty_C);</span><br><span class="line"><span class="built_in">V</span>(empty_B);</span><br></pre></td></tr></table></figure>
<p>这样效率会低, 无需同时取数再算和, 分别取即可.</p>
<p><span class="math inline">\(\square\)</span></p>
<p>6:
桌上有一空盘，最多允许存放一只水果。爸爸可向盘中放一个苹果或放一个桔子；儿子专等吃盘中的桔子，女儿专等吃苹果。用P、V操作实现爸爸、儿子、女儿三个并发进程的同步。</p>
<p>7: 用P、V原语实现过独木桥问题，独木桥最大承重为N人。</p>
<p>8:
某寺庙，有小、老和尚若干，有一水缸，由小和尚提入水缸供老和尚饮用。水缸可容10桶水，水取自同一井中。水井径窄，每次只能容一个水桶取水，水桶总数为3个。每次入、取缸水仅为1桶，且不可同时进行。试给出有关老和尚从缸取水和小和尚打水、入水的算法描述。</p>
<p>9：
有3个进程P1、P2、P3，P1负责生产螺杆，并放入工作台A中；P2负责生产螺母，并放入工作台B中；P3负责从工作台A中取出1个螺杆、从工作台B中取出2个螺母，并组装后输出。工作台A、B的容量分别为10和20，不允许多个进程同时使用同一工作台，且每次操作只能放入或取出一个元件（螺杆或螺母）。请基于信号量机制实现P1、P2、P3间的互斥和同步活动，要求用伪代码描述。</p>
<p>10：
3位参赛者(performer)参与脱口秀表演，现场有5个评委(judge)，每次只能一个人表演，每当表演结束，各个评委开始评判，将分数输入系统，每次仅允许一个评委输入，仅当5个评委都完成打分，下一次表演才能开始。请用信号量机制实现以上角色的互斥和同步活动，并给出相关信号量的定义和主程序main()，要求用伪代码描述。</p>
<p><strong><em>Solution</em></strong> 注意先确定进程的数目, 生产者为 3,
消费者为 5, 则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">semaphore empty[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">// 评委打过分(即消费者是否消费过生产者产生的资源)</span></span><br><span class="line">semaphore full[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">// 表演者表演过(生产者生产的资源)</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">// 评委互斥打分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performer</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">P</span>(empty[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">perform</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">P</span>(full[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(full[i]);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    打分;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(empty[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    parbegin&#123;<span class="built_in">performer</span>(<span class="number">0</span>),...,<span class="built_in">performer</span>(<span class="number">2</span>),<span class="built_in">judge</span>(<span class="number">0</span>),...,<span class="built_in">judge</span>(<span class="number">4</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生产者/消费者问题例三例四.</p>
<p>读者和写者问题示例3.</p>
<p>11:
元宵节爸爸组织兄妹两人猜灯谜，爸爸每出一个谜面，兄妹俩猜答,每人只答一次，出于礼貌，兄妹俩不能同时回答，当两人都回答以后，爸爸公布灯谜答案，然后始出下一个谜面，重复.上述猜谜活动。请用信号量方式，实现爸爸和子女之间的互斥同步流程，注意给出相关信号量定义和注释，要求用伪代码描述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">guess_son=<span class="number">0</span> <span class="comment">// 儿子能否猜谜</span></span><br><span class="line">guess_daughter=<span class="number">0</span> <span class="comment">// 女儿能否猜谜</span></span><br><span class="line">ans_son=<span class="number">1</span> <span class="comment">// 儿子是否回答过</span></span><br><span class="line">ans_daughter=<span class="number">1</span> <span class="comment">// 女儿是否回答过</span></span><br><span class="line">s=<span class="number">1</span> <span class="comment">// 互斥回答</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dad</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(ans_son);</span><br><span class="line">        <span class="built_in">P</span>(ans_daughter);</span><br><span class="line">        <span class="keyword">if</span>(游戏刚开始);</span><br><span class="line">            <span class="comment">// 出谜面</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//公布答案</span></span><br><span class="line">            <span class="comment">// 出谜面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">V</span>(guess_son);</span><br><span class="line">        <span class="built_in">V</span>(guess_daughter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(guess_son);</span><br><span class="line">        <span class="built_in">P</span>(s);</span><br><span class="line">        <span class="comment">// 猜谜</span></span><br><span class="line">        <span class="built_in">V</span>(s);</span><br><span class="line">        <span class="built_in">V</span>(ans_son);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">daughter</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(guess_daughter);</span><br><span class="line">        <span class="built_in">P</span>(s);</span><br><span class="line">        <span class="comment">// 猜谜</span></span><br><span class="line">        <span class="built_in">V</span>(s);</span><br><span class="line">        <span class="built_in">V</span>(ans_daughter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生产者和消费者的动作也要详细写捏, 否则会扣分的捏.</p>
</blockquote>
<h1 id="作业5">作业5</h1>
<p>1.分别举例说明什么是可重用资源和可消耗资源？</p>
<p>2.请论述产生死锁的充分必要条件。</p>
<p>3.如何防止占有且等待条件？</p>
<p>4.如何防止防止循环等待条件？</p>
<p>5.死锁避免、检测和预防之间的区别是什么？</p>
<p>6.什么是安全序列、安全状态？</p>
<p>7.根据伪代码，画出资源分配算法流程图，包括其中银行家算法流程。</p>
<p>8.请简要论述死锁检测流程。</p>
<ol start="9" type="1">
<li>假定系统中有5个进程P1、P2、P3、P4和P5；3类资源A、B和C,其资源数量分别为17、5和20。T0时刻的资源分配情况如下：</li>
</ol>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 13%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>最大资源需求</th>
<th>已分配资源数量</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>P1 P2 P3 P4 P5</td>
<td>5 5 4 4 4</td>
<td>5 3 0 0 2</td>
<td>9 6 11 5 4</td>
<td>2 4 4 2 3</td>
<td>1 0 0 0 1</td>
<td>2 2 5 4 4</td>
</tr>
</tbody>
</table>
<p>系统采用银行家算法实施死锁避免策略，试根据问题7的流程分析如下问题：</p>
<p>① T0时刻是否为安全状态？若是，请给出安全序列。</p>
<p>② T0时刻若进程P2请求资源（0，3，4），是否能实施资源分配？为什么？</p>
<p>③ T0时刻若进程P4请求资源（2，0，1），是否能实施资源分配？为什么？</p>
<h1 id="作业6">作业6</h1>
<ol type="1">
<li><p>简述存储管理的基本功能？</p>
<p>2.什么是重定位，为什么需要重定位？</p>
<p>3.逻辑地址和物理地址之间有什么区别？</p>
<p>4.页和页框之间有什么区别？</p>
<p>5.页和段之间有什么区别？</p>
<p>6.系统使用简单分页，内存大小为 <span
class="math inline">\(2^{32}\)</span> 字节，页大小为 <span
class="math inline">\(2^{10}\)</span> 字节，逻辑地址空间包含 <span
class="math inline">\(2^{16}\)</span> 页。</p>
<p><em>a</em>. 逻辑地址有多少位？</p>
<p><em>b</em>. 一个页框有多少字节</p>
<p><em>c</em>. 物理地址中的多少位是页框号？</p>
<p><em>d</em>. 页表中有多少个表项？</p>
<ol start="7" type="1">
<li>在使用下列内存管理方案的情况下，分别写出逻辑地址0001010010111010转换为物理地址的过程。</li>
</ol>
<ol type="a">
<li><p>分页系统，页面大小为 256
字节，页表中页框号是页号的四分之一</p></li>
<li><p>分段系统，分段的大小为1K，段表中该段的基址 = 22 + 4096 *
段号</p></li>
</ol></li>
<li><p>在一个简单的分段系统中，包括如下段表：</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th><strong>段号</strong></th>
<th><strong>起始地址</strong></th>
<th><strong>长度（字节）</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>660</td>
<td>248</td>
</tr>
<tr class="even">
<td>1</td>
<td>1752</td>
<td>422</td>
</tr>
<tr class="odd">
<td>2</td>
<td>222</td>
<td>198</td>
</tr>
<tr class="even">
<td>3</td>
<td>996</td>
<td>604</td>
</tr>
</tbody>
</table>
<p>对如下的每一个逻辑地址，确定其对应的物理地址或者说明段错误是否发生：</p>
<p>a.0, 198 b.2, 156 c.1, 530 d.3, 444 e. 0, 222</p>
<h1 id="作业7">作业7</h1>
<p>1.简单分页和虚拟分页有何区别？</p>
<p>2.什么是抖动？怎么解决</p>
<p>3.为何在使用虚拟内存时，局部性原理至关重要？</p>
<p>4.在虚拟分页存储管理中，页表项有哪些典型元素？</p>
<p>5.驻留集和工作集有何区别？</p>
<p>6.假设页面大小为4KB，页表项大小为4B。要映射64位的地址空间，如果顶级页表能在一页中存储，需要多少级页表
？</p>
<blockquote>
<p>7.完成PPT中3.6.2二级页表示例3，请采用十进制方式，并与</p>
<p>参考答案比较，自判（此题不提交）。</p>
</blockquote>
<p>7.考虑如下的页面访问序列：7,0,1,2,0,3,0,4,2,3,0,3,2</p>
<p>假设系统为该进程分配了3个页框，并采用局部置换策略。请分别采用先进先出算法、最近最少使用算法、时钟算法和最佳置换算法，画出类似图8.14的图形，并计算每种算法的缺页中断次数和缺页率？只计算页框初始填满后发生的缺页中断，访问总次数从初始页框填满后开始计算。</p>
<p>8.某计算机采用32位段页式虚拟存储器，按字节编址，每个段最多可以有4K页，页大小为8KB，物理主存容量为1024MB。请回答以下问题：
（1） 给出逻辑地址结构并说明理由。 （2）
计算逻辑地址0X4EB9FDE3的段号，段内页号及页内偏移值（最后计算结果须用十六进制表示）。</p>
<p>9:
32位系统页式管理，多级页表。页面1KB，页表项4字节。某进程的页表内容如下页图所示，最外层页表基址为106496。计算逻辑地址201852553的物理地址。</p>
<p><img src="https://raw.githubusercontent.com/baoduoxu/BlogImage/main/image/202311082143060.png" style="zoom:50%;" /></p>
<h1 id="作业8">作业8</h1>
<ol type="1">
<li><p>有哪几种基本I/O控制方式，分别适用于哪些场合？</p></li>
<li><p>试说明DMA的工作流程。</p></li>
<li><p>引入缓冲的主要原因是什么？</p></li>
<li><p>逻辑I/O和设备I/O有什么区别？如何实现设备的独立性？</p></li>
<li><p>何谓虚拟设备？</p></li>
<li><p>试说明SPOOLing系统的组成。</p></li>
<li><p>面向块和面向流的设备有何区别，举一些例子</p></li>
<li><p>磁盘读或写时有哪些延迟因素？</p></li>
<li><p>一个磁盘的参数如下：每个扇区512字节，每道96个扇区，每面110道，共8个面可用，计算存储300000条120字节长的逻辑记录需要多少磁盘空间（扇区、磁道和盘面），忽略文件头记录和磁道索引，并假设记录不能跨越两个扇区。</p></li>
<li><p>考虑第9题中的磁盘系统，假设磁盘转速是360rpm，处理器处理一次I/O中断的时间是2.5µs。</p></li>
</ol>
<p>（1）处理器采用中断驱动I/O方式从磁盘读一个扇区，每个字节中断一次，则处理器用于处理I/O中断的时间占数据传输时间的百分比是多少？</p>
<p>（2）如果采用DMA方式从磁盘读数据，假设每个扇区中断一次，则处理器用于处理I/O中断的时间占数据传输时间的百分比是多少？</p>
<h1 id="project">Project</h1>
<p>设计和实现一个基本的用户级线程库, 完成包括线程的创建, 撤销,
调度等基本功能, 对外提供接口, 同时设计测试用例, 对相关功能加以验证.</p>
<h1
id="计算机操作系统2018-2019学年第二学期期中考试试卷ａ卷">《计算机操作系统》2018-2019学年第二学期期中考试试卷（Ａ卷）</h1>
<p>一、简答题</p>
<ol type="1">
<li><p>PCB主要存储内容是什么？为什么说PCB是操作系统感知进程存在的唯一依据？（20分）</p></li>
<li><p>什么是死锁，死锁的预防与死锁的避免有什么区别。（20分）</p></li>
</ol>
<p>二、 分析题</p>
<ol type="1">
<li>请用信号量机制给出一种哲学家就餐问题的正确解决方案，并说明该方案为什么可以避免死锁。（30分）</li>
<li>现有3个并发进程R、M、P，它们共享一个可循环使用的、大小为N的缓冲区B。进程R负责从输入设备读信息，每读一个字符后，把它存入缓冲区B的一个单元中；进程M负责处理读入的字符，若发现读入的字符中有空格符，则把它改成“.”；进程负责把处理后的字符取出兵打印输出。请用P、V操作实现其同步过程。（30分）</li>
</ol>
<h1 id="实验">实验</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Next at t=5245917341</span><br><span class="line">(0) [0x0000000000faa06c] 000f:000000000000006c (unk. ctxt): jz .+2 (0x10000070)       ; 7402</span><br><span class="line">&lt;bochs:2&gt; 05245917341e[WGUI ] Sim client size(0, 0) != stretched size(720, 400)!</span><br><span class="line">sreg</span><br><span class="line">es:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1</span><br><span class="line">        Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessed</span><br><span class="line">cs:0x000f, dh=0x10c0fb00, dl=0x00000002, valid=1</span><br><span class="line">        Code segment, base=0x10000000, limit=0x00002fff, Execute/Read, Accessed, 32-bit</span><br><span class="line">ss:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1</span><br><span class="line">        Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessed</span><br><span class="line">ds:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=3</span><br><span class="line">        Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessed</span><br><span class="line">fs:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1</span><br><span class="line">        Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessed</span><br><span class="line">gs:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1</span><br><span class="line">        Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessed</span><br><span class="line">ldtr:0x0068, dh=0x000082fd, dl=0x92d00068, valid=1</span><br><span class="line">tr:0x0060, dh=0x00008bfd, dl=0x92e80068, valid=1</span><br><span class="line">gdtr:base=0x0000000000005cb8, limit=0x7ff</span><br><span class="line">idtr:base=0x00000000000054b8, limit=0x7ff</span><br><span class="line">&lt;bochs:3&gt; xp /2w 0x0000000000005cb8+13*8</span><br><span class="line">[bochs]:</span><br><span class="line">0x0000000000005d20 &lt;bogus+       0&gt;:    0x92d00068      0x000082fd</span><br><span class="line">&lt;bochs:4&gt; xp /2w 0x00fd92d0+2*8</span><br><span class="line">[bochs]:</span><br><span class="line">0x0000000000fd92e0 &lt;bogus+       0&gt;:    0x00003fff      0x10c0f300</span><br><span class="line">&lt;bochs:5&gt; creg</span><br><span class="line">CR0=0x8000001b: PG cd nw ac wp ne ET TS em MP PE</span><br><span class="line">CR2=page fault laddr=0x0000000010002fa8</span><br><span class="line">CR3=0x0000000000000000</span><br><span class="line">    PCD=page-level cache disable=0</span><br><span class="line">    PWT=page-level write-through=0</span><br><span class="line">CR4=0x00000000: smep osxsave pcid fsgsbase smx vmx osxmmexcpt osfxsr pce pge mce pae pse de tsd pvi vme</span><br><span class="line">EFER=0x00000000: ffxsr nxe lma lme sce</span><br><span class="line">&lt;bochs:6&gt; xp /2w 0x40*4</span><br><span class="line">[bochs]:</span><br><span class="line">0x0000000000000100 &lt;bogus+       0&gt;:    0x00fa7027      0x00000000</span><br><span class="line">&lt;bochs:7&gt; xp /2w 0x00fa7000+3*4</span><br><span class="line">[bochs]:</span><br><span class="line">0x0000000000fa700c &lt;bogus+       0&gt;:    0x00fa6067      0x00000000</span><br><span class="line">&lt;bochs:8&gt; xp /w 0xfa6000+4</span><br><span class="line">[bochs]:</span><br><span class="line">0x0000000000fa6004 &lt;bogus+       0&gt;:    0x80911010</span><br><span class="line">&lt;bochs:9&gt; setpmem 0x00fa6004 4 0</span><br><span class="line">&lt;bochs:10&gt; xp /w 0xfa6000+4</span><br><span class="line">[bochs]:</span><br><span class="line">0x0000000000fa6004 &lt;bogus+       0&gt;:    0x00000000</span><br><span class="line">&lt;bochs:11&gt; 05245917341e[WGUI ] Sim client size(0, 0) != stretched size(720, 400)!</span><br><span class="line">c</span><br><span class="line">06024800000e[WGUI ] Sim client size(0, 0) != stretched size(720, 400)!</span><br></pre></td></tr></table></figure>
<hr />
<!-- Kernel: 一个为正在运行的程序提供服务的特殊的程序. 一台计算机只有一个内核.

正在运行的程序称为进程(process), 进程有包含指令、数据和堆栈的内存.

堆栈: 组织程序的过程调用.

进程调用内核服务时, 它会调用一个**系统调用**(system call), 系统调用是指操作系统提供给应用程序的一组接口，用于访问操作系统的功能和资源. 它允许应用程序通过调用特殊的函数或指令请求操作系统来执行某些任务.

shell 是一个普通的用户程序, 不是内核的一部分, 从用户那里读取命令并执行.

内核提供的系统调用集合是用户程序看到的接口, 下面是 xv6 kernel 所有的系统调用.

| **系统调用**                            | **描述**                                                     |
| --------------------------------------- | ------------------------------------------------------------ |
| `int fork()`                            | 创建一个进程，返回子进程(已有的进程创建的进程)的PID(进程标识符) |
| `int exit(int status)`                  | 终止当前进程(并释放资源, 比如内存和打开的文件)，并将状态报告给wait()函数。无返回, 通常0表示成功, 1表示失败 |
| `int wait(int *status)`                 | 等待一个子进程退出; 将退出状态存入*status; 返回子进程PID; 如果调用者没有子进程, 立刻返回 `-1`, 若不关注子进程的退出状态, 可以直接 `wait((int *)0)`. |
| `int kill(int pid)`                     | 终止对应PID的进程，返回 $0$，或返回 $-1$ 表示错误            |
| `int getpid()`                          | 返回当前进程的PID                                            |
| `int sleep(int n)`                      | 暂停 $n$ 个时钟节拍                                          |
| `int exec(char *file, char *argv[])`    | 加载一个文件并使用参数执行它; 只有在出错时才返回             |
| `char *sbrk(int n)`                     | 给进程的内存增加 $n$ 字节。返回新内存的起始地址              |
| `int open(char *file, int flags)`       | 打开一个文件；flags表示read/write；返回一个fd（文件描述符）  |
| `int write(int fd, char *buf, int n)`   | 从buf 写n 个字节到文件描述符fd; 返回n                        |
| `int read(int fd, char *buf, int n)`    | 将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0     |
| `int close(int fd)`                     | 释放打开的文件fd                                             |
| `int dup(int fd)`                       | 返回一个新的文件描述符，指向与fd 相同的文件                  |
| `int pipe(int p[])`                     | 创建一个管道，把read/write文件描述符放在p[0]和p[1]中         |
| `int chdir(char *dir)`                  | 改变当前的工作目录                                           |
| `int mkdir(char *dir)`                  | 创建一个新目录                                               |
| `int mknod(char *file, int, int)`       | 创建一个设备文件                                             |
| `int fstat(int fd, struct stat *st)`    | 将打开文件fd的信息放入*st                                    |
| `int stat(char *file, struct stat *st)` | 将指定名称的文件信息放入*st                                  |
| `int link(char *file1, char *file2)`    | 为文件file1创建另一个名称(file2)                             |
| `int unlink(char *file)`                | 删除一个文件                                                 |

> call 和 invoke 的区别?

## 1.1 进程和内存

一个进程使用系统调用 `fork` 来创建一个新的进程, 新的进程称为子进程, 其内存内容与调用它的进程(称为父进程)相同. 在父进程中, `fork` 返回子进程的PID, 在子进程中, `fork` 返回零.



<---已知玉米投手的攻击频率为 $t$ 一次, 每次攻击有 $p$ 的概率投出黄油, 玉米粒和黄油的伤害分别为 $h_1,h_2$ , 黄油可将僵尸定身 $s$ 秒, 僵尸血量为 $H$, 速度为 $v$, 初始条件下僵尸与玉米投手的距离为 $x$. 不考虑玉米投手的生命值.

1. 求玉米投手能在自己被吃掉之前将僵尸击杀的概率.
2. 求在玉米投手能够将僵尸击杀的条件下, 求其将僵尸击杀的所需时间的期望.
3. 若可以在同一地点叠种玉米投手, 求至少要叠种多少棵玉米投手, 才能以 $99\%$ 的概率将僵尸击杀? (所有玉米投手同时攻击)--->

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/25/OR/int-prop/lagrangian-duality/" rel="prev" title="拉格朗日对偶">
                  <i class="fa fa-angle-left"></i> 拉格朗日对偶
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/07/25/essay/essay/" rel="next" title="一些做题记录">
                  一些做题记录 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class=""></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Baoduo Xu</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">286k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">4:20</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
